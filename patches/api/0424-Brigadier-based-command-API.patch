From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 1 Aug 2022 22:50:29 -0400
Subject: [PATCH] Brigadier based command API


diff --git a/build.gradle.kts b/build.gradle.kts
index 3c4dd6ebc2289c44c2f5723e7920aadffdc51884..3886e6d53b512232837755895a052af50684b809 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -45,7 +45,7 @@ dependencies {
     implementation("org.ow2.asm:asm:9.2")
     implementation("org.ow2.asm:asm-commons:9.2")
     // Paper end
-
+    api("com.mojang:brigadier:1.0.18") // Paper, expose!
     compileOnly("org.apache.maven:maven-resolver-provider:3.8.5")
     compileOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.3")
     compileOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.3")
diff --git a/src/main/java/io/papermc/paper/command/brigadier/CommandBuilder.java b/src/main/java/io/papermc/paper/command/brigadier/CommandBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1918953532ba9e10614510b7e4da66fb641c4af1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/CommandBuilder.java
@@ -0,0 +1,152 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.builder.ArgumentBuilder;
+import com.mojang.brigadier.tree.RootCommandNode;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A CommandBuilder gives you a proper way of registering brig commands.
+ * This will properly connect your brig commands to your plugin, ensuring that
+ * they are shown in /help, etc.
+ */
+@ApiStatus.Experimental
+public class CommandBuilder extends ArgumentBuilder<CommandSourceStack, CommandBuilder> {
+
+    private final Plugin plugin;
+    private final String literal;
+
+    private String description;
+    private List<String> aliases = List.of();
+
+    @ApiStatus.Internal
+    protected CommandBuilder(@NotNull Plugin plugin, @NotNull String literal) {
+        this.literal = literal;
+        this.plugin = plugin;
+    }
+
+    /**
+     * Creates a new command builder.
+     *
+     * @param plugin plugin
+     * @param name   command name
+     * @return builder
+     */
+    @NotNull
+    public static CommandBuilder of(@NotNull Plugin plugin, @NotNull String name) {
+        return new CommandBuilder(plugin, name);
+    }
+
+    /**
+     * Sets the aliases for this command.
+     *
+     * @param aliases alises
+     * @return self
+     */
+    @NotNull
+    public CommandBuilder aliases(@NotNull String... aliases) {
+        this.aliases = Arrays.asList(aliases);
+        return this.getThis();
+    }
+
+    /**
+     * Gets the description for this command.
+     *
+     * @return description
+     */
+    @NotNull
+    public String getDescription() {
+        return this.description;
+    }
+
+    /**
+     * Sets the description for this command.
+     *
+     * @param description description
+     * @return self
+     */
+    @NotNull
+    public CommandBuilder description(@NotNull String description) {
+        this.description = description;
+        return this.getThis();
+    }
+
+    /**
+     * Gets the plugin set for this command builder.
+     *
+     * @return self
+     */
+    @NotNull
+    public Plugin getPlugin() {
+        return this.plugin;
+    }
+
+    /**
+     * Returns self instance for builder pattern.
+     *
+     * @return self
+     */
+    @NotNull
+    @Override
+    protected CommandBuilder getThis() {
+        return this;
+    }
+
+    /**
+     * Builds the raw command node.
+     *
+     * @return raw node
+     */
+    @NotNull
+    @ApiStatus.Internal
+    @Override
+    public PluginCommandNode build() {
+        // See: LiteralArgumentBuilder
+        return new PluginCommandNode(this.literal, this);
+    }
+
+    /**
+     * Registers this command builder into the server
+     * dispatcher.
+     */
+    public void register() {
+        this.register(Bukkit.getServer().getCommandDispatcher());
+    }
+
+    /**
+     * Registers the command builder into the specified dispatcher.
+     *
+     * @param dispatcher dispatcher
+     */
+    public void register(@NotNull CommandDispatcher<CommandSourceStack> dispatcher) {
+        String identifier = this.plugin.getDescription().getName();
+        RootCommandNode<CommandSourceStack> dispatcherRoot = dispatcher.getRoot();
+        PluginCommandNode root = this.build();
+
+        dispatcherRoot.addChild(root);
+        // Add root redirect
+        this.registerRedirect(dispatcherRoot, root, identifier + ":" + this.literal);
+
+        // Add aliases
+        for (String alias : this.aliases) {
+            this.registerRedirect(dispatcherRoot, root, alias);
+            this.registerRedirect(dispatcherRoot, root, identifier + ":" + alias);
+        }
+    }
+
+    private void registerRedirect(@NotNull RootCommandNode<CommandSourceStack> dispatcherRoot, @NotNull PluginCommandNode node, @NotNull String name) {
+        PluginCommandNode aliasRoot = CommandBuilder.of(this.plugin, name)
+            .description(this.description)
+            .redirect(node)
+            .executes(node.getCommand())
+            .build();
+
+        dispatcherRoot.addChild(aliasRoot);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/CommandSigningContext.java b/src/main/java/io/papermc/paper/command/brigadier/CommandSigningContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..20bac2b1b21ffd05aee443ecd4340a96c20ee830
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/CommandSigningContext.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.command.brigadier;
+
+import net.kyori.adventure.chat.SignedMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Stored in a CommandSourceStack, allows signed argument information
+ * to be exposed.
+ */
+public interface CommandSigningContext {
+
+    /**
+     * Gets a signed message argument data from this signing context.
+     * Null if this argument isn't present.
+     *
+     * @param argumentName name
+     * @return signed message
+     */
+    @Nullable
+    SignedMessage getSignedMessage(@NotNull String argumentName);
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..1462e95756a85d99f39d29b28c734b367890df44
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
@@ -0,0 +1,52 @@
+package io.papermc.paper.command.brigadier;
+
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents a vanilla command source stack which is used
+ * for command execution.
+ */
+@ApiStatus.NonExtendable
+public interface CommandSourceStack {
+
+    /**
+     * Gets the bukkit entity running this command.
+     * @return bukkit entity, null if not present
+     */
+    @Nullable
+    Entity getBukkitEntity();
+
+    /**
+     * Gets the world that this command is being executed in.
+     * @return world
+     */
+    @Nullable
+    World getBukkitWorld();
+
+    /**
+     * Gets the location that this command is being executed in.
+     * @return location
+     */
+    @Nullable
+    Location getBukkitLocation();
+
+    /**
+     * Gets the sender representing this source stack.
+     * @return source stack sender
+     */
+    @NotNull
+    CommandSender getBukkitSender();
+
+    /**
+     * Gets the signing context for this source stack.
+     * @return signing context
+     */
+    @NotNull
+    CommandSigningContext getCommandSigningContext();
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..94305f3f35d5f807381dcd3b26200f86cb0816e8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.Message;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.ComponentSerializer;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ServiceLoader;
+
+/**
+ * A component serializer that converts it to a brigadier compatible type.
+ */
+public interface MessageComponentSerializer extends ComponentSerializer<Component, Component, Message> {
+
+    /**
+     * A component serializer that converts it to a brigadier compatible type.
+     *
+     * @return serializer instance
+     */
+    @NotNull
+    static MessageComponentSerializer message() {
+        return Holder.PROVIDER;
+    }
+
+
+    @ApiStatus.Internal
+    class Holder {
+        public static final MessageComponentSerializer PROVIDER = ServiceLoader.load(MessageComponentSerializer.class)
+            .findFirst()
+            .orElseThrow();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PluginCommandNode.java b/src/main/java/io/papermc/paper/command/brigadier/PluginCommandNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee073108df90ffdc58b524da03e76fa671757eeb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/PluginCommandNode.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+@ApiStatus.Internal
+public class PluginCommandNode extends LiteralCommandNode<CommandSourceStack> {
+
+    private final Plugin plugin;
+    private final String description;
+
+    public PluginCommandNode(@NotNull String literal, @NotNull CommandBuilder builder) {
+        super(
+            literal, builder.getCommand(), builder.getRequirement(),
+            builder.getRedirect(), builder.getRedirectModifier(), builder.isFork()
+        );
+        this.plugin = builder.getPlugin();
+        this.description = builder.getDescription();
+
+        for (CommandNode<CommandSourceStack> argument : builder.getArguments()) {
+            this.addChild(argument);
+        }
+    }
+
+    @NotNull
+    public Plugin getPlugin() {
+        return this.plugin;
+    }
+
+    @NotNull
+    public String getDescription() {
+        return this.description;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab25823284bd196b3c5538e1a654f7cc48efc80d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Argument type returned from the Message argument.
+ * Note you must use the {@link io.papermc.paper.command.brigadier.CommandSigningContext} to retrieve
+ * the signed information for this.
+ */
+public interface MessageArgumentResponse {
+
+    /**
+     * Content of the message
+     * @return player made message
+     */
+    @NotNull
+    String content();
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArguments.java b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArguments.java
new file mode 100644
index 0000000000000000000000000000000000000000..d77d9e2131d395aaee23914a8b40a7cf52c7d011
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArguments.java
@@ -0,0 +1,82 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import org.bukkit.block.BlockState;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ServiceLoader;
+import java.util.UUID;
+
+/**
+ * Vanilla argument registry
+ *
+ * These provide rich argument parsing on the client and
+ * may also provide additional signing context.
+ */
+public final class VanillaArguments {
+
+    @NotNull
+    private static final VanillaArgumentProvider PROVIDER = ServiceLoader.load(VanillaArgumentProvider.class)
+        .findFirst()
+        .orElseThrow();
+
+    /**
+     * An ItemStack argument which provides rich parsing for
+     * specifying item material and item NBT information.
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<ItemStack> itemStack() {
+        return PROVIDER.itemStack();
+    }
+
+    /**
+     * A blockstate argument which will provide rich parsing for specifying
+     * the specific block variant and then the block entity NBT if applicable.
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<BlockState> blockState() {
+        return PROVIDER.blockState();
+    }
+
+    /**
+     * A uuid argument.
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<UUID> uuid() {
+        return PROVIDER.uuid();
+    }
+
+    /**
+     * A signed message argument.
+     * You must get the signed data for this argument
+     * from the {@link io.papermc.paper.command.brigadier.CommandSigningContext}.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<MessageArgumentResponse> signedMessage() {
+        return PROVIDER.signedMessage();
+    }
+
+    @ApiStatus.Internal
+    interface VanillaArgumentProvider {
+
+        @NotNull
+        ArgumentType<ItemStack> itemStack();
+
+        @NotNull
+        ArgumentType<BlockState> blockState();
+
+        @NotNull
+        ArgumentType<MessageArgumentResponse> signedMessage();
+
+        @NotNull
+        ArgumentType<UUID> uuid();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/WrapperArgumentType.java b/src/main/java/io/papermc/paper/command/brigadier/argument/WrapperArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..da409fd6b5888d5d592daa6c5cb2325e6d8ea35d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/WrapperArgumentType.java
@@ -0,0 +1,84 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+
+/**
+ * An argument type that wraps around another argument.
+ * This argument is special in that the argument type that is wrapped will
+ * be sent to the client, not the wrapper itself.
+ *
+ * @param <T> type
+ * @param <B> base wrapping type
+ */
+public abstract class WrapperArgumentType<T, B> implements ArgumentType<T> {
+
+    @NotNull
+    private final ArgumentType<B> baseArgumentType;
+
+    public WrapperArgumentType(@NotNull ArgumentType<B> baseArgumentType) {
+        this.baseArgumentType = baseArgumentType;
+    }
+
+    /**
+     * Parses the argument using the wrapped argument type then converting
+     * it.
+     * @param reader string reader
+     * @return value
+     * @throws CommandSyntaxException if an error occurs while parsing
+     */
+    @NotNull
+    @Override
+    public T parse(@NotNull StringReader reader) throws CommandSyntaxException {
+        return this.convert(this.baseArgumentType.parse(reader));
+    }
+
+    /**
+     * Converts the type from the wrapped argument to this argument.
+     *
+     * @param baseType wrapped argument provided value
+     * @return converted value
+     * @throws CommandSyntaxException if an exception occurs while parsing
+     */
+    @NotNull
+    public abstract T convert(@NotNull B baseType) throws CommandSyntaxException;
+
+    /**
+     * Gets the wrapped argument.
+     *
+     * @return wrapped
+     */
+    @NotNull
+    public ArgumentType<B> getWrapped() {
+        return this.baseArgumentType;
+    }
+
+    /**
+     * Cannot be controlled by the server.
+     * Returned in cases where there are multiple arguments in the same node.
+     * This helps differentiate and tell the player what the possible inputs are.
+     *
+     * @return client set examples
+     */
+    @NotNull
+    @Override
+    public final Collection<String> getExamples() {
+        return this.baseArgumentType.getExamples();
+    }
+
+    /**
+     * Returns if the argument itself should handle sugggestion
+     * parsing instead of the wrapper.
+     *
+     * @return handles suggestions
+     */
+    public boolean handleSuggestions() {
+        return false;
+    }
+
+
+}
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
index ac9b690fcccb60b587e5345f12f1383afd0a73a1..f0b2df54f47f3db3090a8084b5f669c4bc47bd92 100644
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -2338,6 +2338,7 @@ public final class Bukkit {
      * @return the default message
      */
     @NotNull
+    @Deprecated // Used only for bukkit commands
     public static net.kyori.adventure.text.Component permissionMessage() {
         return server.permissionMessage();
     }
@@ -2458,6 +2459,11 @@ public final class Bukkit {
     public static @NotNull org.bukkit.potion.PotionBrewer getPotionBrewer() {
         return server.getPotionBrewer();
     }
+
+    @NotNull
+    public static com.mojang.brigadier.CommandDispatcher<io.papermc.paper.command.brigadier.CommandSourceStack> getCommandDispatcher() {
+        return server.getCommandDispatcher();
+    }
     // Paper end
 
     @NotNull
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index 2204336d8800311b65e894739ab1b27273e7c6f2..6a56d7a7c4739d9a6ab639479ff4fcd97e88407d 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -2033,6 +2033,7 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      *
      * @return the default message
      */
+    @Deprecated // Paper - only used for bukkit commands
     @NotNull net.kyori.adventure.text.Component permissionMessage();
 
     /**
@@ -2138,5 +2139,8 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      * @return the potion brewer
      */
     @NotNull org.bukkit.potion.PotionBrewer getPotionBrewer();
+
+    @NotNull
+    com.mojang.brigadier.CommandDispatcher<io.papermc.paper.command.brigadier.CommandSourceStack> getCommandDispatcher();
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index 854be548e5a645e7312e6e9390d5255f8b1d61e6..fb55e26a51ad4a326cfa5a640c7ca1b32ecb64d2 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -270,5 +270,7 @@ public interface UnsafeValues {
      * @throws IllegalStateException if no biome by the given key is registered.
      */
     void setBiomeKey(RegionAccessor accessor, int x, int y, int z, NamespacedKey biomeKey);
+
+    java.util.Map<String, org.bukkit.command.Command> getCommandMirrorMap();
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index 608b541aef01f33891a492fff5b8400496832c3a..6eba1ba7ce2f569de3382264ebfab85d7ee8c3c6 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -488,4 +488,7 @@ public abstract class Command {
     public String toString() {
         return getClass().getName() + '(' + name + ')';
     }
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public boolean canBeOverriden() { return false; } // Paper
 }
diff --git a/src/main/java/org/bukkit/command/CommandMap.java b/src/main/java/org/bukkit/command/CommandMap.java
index 864c263bbd4dd6dd7c37a74b39b1a40a884d0731..88d92350b59333c2148190c5e4974f254b0139a9 100644
--- a/src/main/java/org/bukkit/command/CommandMap.java
+++ b/src/main/java/org/bukkit/command/CommandMap.java
@@ -5,6 +5,7 @@ import org.bukkit.Location;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+@Deprecated(forRemoval = true) // Paper
 public interface CommandMap {
 
     /**
diff --git a/src/main/java/org/bukkit/command/FormattedCommandAlias.java b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
index 9d4f553c04784cca63901a56a7aea62a5cae1d72..abe256e1e45ce28036da4aa1586715bc8a1a3414 100644
--- a/src/main/java/org/bukkit/command/FormattedCommandAlias.java
+++ b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
@@ -117,7 +117,7 @@ public class FormattedCommandAlias extends Command {
             index = formatString.indexOf('$', index);
         }
 
-        return formatString;
+        return formatString.trim(); // Paper - Causes an extra space at the end, breaks with brig commands
     }
 
     @NotNull
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index b8623575b1c1b565560c2dd6438190716845a652..20d98ae884303c795334abd269a397fbd6b37001 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -5,7 +5,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -21,8 +20,9 @@ import org.bukkit.util.StringUtil;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+@Deprecated // Paper
 public class SimpleCommandMap implements CommandMap {
-    protected final Map<String, Command> knownCommands = new HashMap<String, Command>();
+    protected final Map<String, Command> knownCommands = org.bukkit.Bukkit.getUnsafe().getCommandMirrorMap();
     private final Server server;
 
     public SimpleCommandMap(@NotNull final Server server) {
@@ -114,7 +114,9 @@ public class SimpleCommandMap implements CommandMap {
         // If the command exists but is an alias we overwrite it, otherwise we return
         Command conflict = knownCommands.get(label);
         if (conflict != null && conflict.getLabel().equals(label)) {
+            if (!conflict.canBeOverriden()) { // Paper
             return false;
+            } // Paper
         }
 
         if (!isAlias) {
@@ -129,7 +131,7 @@ public class SimpleCommandMap implements CommandMap {
      * {@inheritDoc}
      */
     @Override
-    public boolean dispatch(@NotNull CommandSender sender, @NotNull String commandLine) throws CommandException {
+        public boolean dispatch(@NotNull CommandSender sender, @NotNull String commandLine) throws CommandException {
         String[] args = org.apache.commons.lang3.StringUtils.split(commandLine, ' '); // Paper - fix adjacent spaces (from console/plugins) causing empty array elements
 
         if (args.length == 0) {
diff --git a/src/test/java/org/bukkit/TestServer.java b/src/test/java/org/bukkit/TestServer.java
index bfb39f48bea14ad616c53e2a8a6901e93f728768..d118995de8397538ea83ad89b14e9eda2acb8d6d 100644
--- a/src/test/java/org/bukkit/TestServer.java
+++ b/src/test/java/org/bukkit/TestServer.java
@@ -124,7 +124,7 @@ public final class TestServer implements InvocationHandler {
             TestServer server = new TestServer();
             Server instance = Proxy.getProxyClass(Server.class.getClassLoader(), Server.class).asSubclass(Server.class).getConstructor(InvocationHandler.class).newInstance(server);
             Bukkit.setServer(instance);
-            server.pluginManager = new SimplePluginManager(instance, new SimpleCommandMap(instance));
+            server.pluginManager = new SimplePluginManager(instance, null);
         } catch (Throwable t) {
             throw new Error(t);
         }
