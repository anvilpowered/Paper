From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 1 Aug 2022 22:50:29 -0400
Subject: [PATCH] Brigadier based command API


diff --git a/build.gradle.kts b/build.gradle.kts
index 149f9088fe806467656e8b1c4157df60fda69ba7..24b533f277092d1e70ca1d5e5e8f67bd1e3da8fd 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -51,6 +51,7 @@ dependencies {
     implementation("org.ow2.asm:asm-commons:9.4")
     // Paper end
 
+    api("com.mojang:brigadier:1.0.18") // Paper, expose!
     api("org.apache.maven:maven-resolver-provider:3.8.5")
     compileOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.3")
     compileOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.3")
diff --git a/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..deb6ccfb5b0456280b99325e839cd72fca50a86d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/CommandSourceStack.java
@@ -0,0 +1,58 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import io.papermc.paper.command.brigadier.argument.ArgumentResolver;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Entity;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents a vanilla command source stack which is used
+ * for command execution.
+ */
+@ApiStatus.NonExtendable
+@ApiStatus.Experimental
+public interface CommandSourceStack {
+
+    /**
+     * Gets the location that this command is being executed at.
+     * @return location
+     */
+    @NotNull
+    Location getLocation();
+
+    /**
+     * Gets the source of from where this command was executed from
+     * @return source type
+     */
+    @NotNull
+    CommandSender getSender();
+
+    /**
+     * Gets the entity that triggered the execution of this command.
+     * May not always be the command source.
+     */
+    @Nullable
+    Entity getExecutor();
+
+    /**
+     * Resolves an argument in this command source stack.
+     *
+     * @param context command context
+     * @param name name of argument
+     * @return resolved argument
+     * @param <V> resolved argument type
+     */
+    @NotNull
+    @SuppressWarnings("unchecked")
+    default <V> V getResolvedArgument(@NotNull CommandContext<CommandSourceStack> context, @NotNull final String name) throws CommandSyntaxException {
+        ArgumentResolver<?> resolver = context.getArgument(name, ArgumentResolver.class);
+        return (V) resolver.resolve(this);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/Commands.java b/src/main/java/io/papermc/paper/command/brigadier/Commands.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca8ff133e8515855badd64a094149043350b9fa2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/Commands.java
@@ -0,0 +1,187 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import java.util.Collections;
+import java.util.List;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents the general holder for commands.
+ */
+@ApiStatus.Experimental
+public interface Commands {
+
+    /**
+     * Utility to create a literal command node builder with the correct generic.
+     *
+     * @param literal literal name
+     * @return builder
+     */
+    @NotNull
+    static LiteralArgumentBuilder<CommandSourceStack> literal(@NotNull String literal) {
+        return LiteralArgumentBuilder.literal(literal);
+    }
+
+    /**
+     * Utility to create a required argument builder with the correct generic.
+     *
+     * @param name name
+     * @param argumentType type
+     * @return value
+     * @param <T> argument type
+     */
+    @NotNull
+    static <T> RequiredArgumentBuilder<CommandSourceStack, T> argument(@NotNull String name, @NotNull ArgumentType<T> argumentType) {
+        return RequiredArgumentBuilder.argument(name, argumentType);
+    }
+
+    /**
+     * Gets the underlying {@link CommandDispatcher}.
+     *
+     * <p><b>Note:</b> This is a delicate API that must be used with care to ensure a consistent user experience.</p>
+     *
+     * <p>When registering commands, it should be preferred to use {@link #register(Plugin, LiteralCommandNode, String, List) register methods}
+     * over directly registering to the dispatcher wherever possible. {@link #register(Plugin, LiteralCommandNode, String, List) Register methods}
+     * automatically handle command namespacing, command help, plugin association with commands, and more.</p>
+     *
+     * <p>Example use cases for this method <b>may</b> include:
+     * <ul>
+     *   <li>Implementing integration between an external command framework and Paper (although {@link #register(Plugin, LiteralCommandNode, String, List) register methods} should still be preferred where possible)</li>
+     *   <li>Registering new child nodes to an existing plugin command (for example an "addon" plugin to another plugin may want to do this)</li>
+     *   <li>Retrieving existing command nodes to build redirects</li>
+     * </ul>
+     * @return dispatcher
+     */
+    @NotNull
+    CommandDispatcher<CommandSourceStack> getDispatcher();
+
+    /**
+     * Registers a command for a plugin.
+     *
+     * <p>Commands have certain the overriding behavior of:
+     * <ul>
+     *   <li>Aliases will not override already existing commands (excluding namespaced ones)</li>
+     *   <li>The main command/namespaced label will override already existing commands</li>
+     * </ul>
+     *
+     * @param plugin the owning plugin
+     * @param node the built literal command node
+     * @return true if the command was registered successfully
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull LiteralCommandNode<CommandSourceStack> node) {
+        return this.register(plugin, node, null, Collections.emptyList());
+    }
+
+    /**
+     * Registers a command for a plugin.
+     *
+     * <p>Commands have certain the overriding behavior of:
+     * <ul>
+     *   <li>Aliases will not override already existing commands (excluding namespaced ones)</li>
+     *   <li>The main command/namespaced label will override already existing commands</li>
+     * </ul>
+     *
+     * @param plugin the owning plugin
+     * @param node the built literal command node
+     * @param description the help description for the root literal node
+     * @return true if the command was registered successfully
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull LiteralCommandNode<CommandSourceStack> node, @Nullable String description) {
+        return this.register(plugin, node, description, Collections.emptyList());
+    }
+
+    /**
+     * Registers a command for a plugin.
+     *
+     * <p>Commands have certain the overriding behavior of:
+     * <ul>
+     *   <li>Aliases will not override already existing commands (excluding namespaced ones)</li>
+     *   <li>The main command/namespaced label will override already existing commands</li>
+     * </ul>
+     *
+     * @param plugin the owning plugin
+     * @param node the built literal command node
+     * @param aliases a collection of aliases to register the literal node's command to
+     * @return true if the literal node or at least one alias was registered successfully
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull LiteralCommandNode<CommandSourceStack> node, @NotNull List<String> aliases) {
+        return this.register(plugin, node, null, aliases);
+    }
+
+    /**
+     * Registers a command for a plugin.
+     *
+     * <p>Commands have certain the overriding behavior of:
+     * <ul>
+     *   <li>Aliases will not override already existing commands (excluding namespaced ones)</li>
+     *   <li>The main command/namespaced label will override already existing commands</li>
+     * </ul>
+     *
+     * @param plugin the owning plugin
+     * @param node the built literal command node
+     * @param description the help description for the root literal node
+     * @param aliases a collection of aliases to register the literal node's command to
+     * @return true if the literal node or at least one alias was registered successfully
+     */
+    boolean register(@NotNull Plugin plugin, @NotNull LiteralCommandNode<CommandSourceStack> node, @Nullable String description, @NotNull List<String> aliases);
+
+    /**
+     * Registers a command under the same logic as {@link Commands#register(Plugin, LiteralCommandNode, String, List)}.
+     *
+     * @param plugin plugin instance
+     * @param label command label
+     * @param simpleCommand command implementation
+     * @return true if the command was registered
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull String label, @NotNull SimpleCommand simpleCommand) {
+        return this.register(plugin, label, null, Collections.emptyList(), simpleCommand);
+    }
+
+    /**
+     * Registers a command under the same logic as {@link Commands#register(Plugin, LiteralCommandNode, String, List)}.
+     *
+     * @param plugin plugin instance
+     * @param label command label
+     * @param description the help description for the root literal node
+     * @param simpleCommand command implementation
+     * @return true if the command was registered
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull String label, @Nullable String description, @NotNull SimpleCommand simpleCommand) {
+        return this.register(plugin, label, description, Collections.emptyList(), simpleCommand);
+    }
+
+    /**
+     * Registers a command under the same logic as {@link Commands#register(Plugin, LiteralCommandNode, String, List)}.
+     *
+     * @param plugin plugin instance
+     * @param label command label
+     * @param aliases a collection of aliases
+     * @param simpleCommand command implementation
+     * @return true if at least one label was properly registered
+     * into the dispatcher
+     */
+    default boolean register(@NotNull Plugin plugin, @NotNull String label, @NotNull List<String> aliases, @NotNull SimpleCommand simpleCommand) {
+        return this.register(plugin, label, null, aliases, simpleCommand);
+    }
+
+    /**
+     * Registers a command under the same logic as {@link Commands#register(Plugin, LiteralCommandNode, String, List)}.
+     *
+     * @param plugin plugin instance
+     * @param label command label
+     * @param description the help description for the root literal node
+     * @param aliases a collection of aliases
+     * @param simpleCommand command implementation
+     * @return true if at least one label was properly registered
+     * into the dispatcher
+     */
+    boolean register(@NotNull Plugin plugin, @NotNull String label, @Nullable String description, @NotNull List<String> aliases, @NotNull SimpleCommand simpleCommand);
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cbd2e3f79a0a550d8b1a249996b2058b24717a9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializer.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.Message;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.ComponentSerializer;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ServiceLoader;
+
+/**
+ * A component serializer that converts it to a brigadier compatible type.
+ */
+@ApiStatus.Experimental
+public interface MessageComponentSerializer extends ComponentSerializer<Component, Component, Message> {
+
+    /**
+     * A component serializer that converts it to a brigadier compatible type.
+     *
+     * @return serializer instance
+     */
+    @NotNull
+    static MessageComponentSerializer message() {
+        return MessageComponentSerializerHolder.PROVIDER;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerHolder.java b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3b8cc535cfa74a16cd35ed5677c6958b894046d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerHolder.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.command.brigadier;
+
+import java.util.ServiceLoader;
+
+final class MessageComponentSerializerHolder {
+
+    public static final MessageComponentSerializer PROVIDER = ServiceLoader.load(MessageComponentSerializer.class)
+        .findFirst()
+        .orElseThrow();
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/SimpleCommand.java b/src/main/java/io/papermc/paper/command/brigadier/SimpleCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..31c8ae2e70457b17c5c7145444e4e8fea8da469f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/SimpleCommand.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * This represents a simple command implementation that is wrapped
+ * around brigadier.
+ */
+@ApiStatus.Experimental
+public interface SimpleCommand {
+
+    /**
+     * Executes the command with the given context and arguments.
+     *
+     * @param context The context of the command.
+     * @param args The arguments of the command.
+     * @return The result of the command execution.
+     */
+    int execute(@NotNull CommandContext<CommandSourceStack> context, @NotNull String[] args);
+
+    /**
+     * Suggests possible completions for the given command context and arguments.
+     *
+     * @param context The context of the command.
+     * @param builder The suggestions builder.
+     * @param args The arguments of the command.
+     * @return A completable future containing the suggestions.
+     */
+    @NotNull
+    CompletableFuture<Suggestions> suggest(@NotNull CommandContext<CommandSourceStack> context, @NotNull SuggestionsBuilder builder, @NotNull String[] args);
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/ArgumentResolver.java b/src/main/java/io/papermc/paper/command/brigadier/argument/ArgumentResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..82b4e806dfad980df49146b8ae61f238208bd174
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/ArgumentResolver.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents an argument which requires
+ * the context of a command source stack to be fully resolved.
+ * @param <T> type
+ */
+@ApiStatus.Experimental
+public interface ArgumentResolver<T> {
+
+    /**
+     * Resolves the argument with the given
+     * command source stack.
+     * @param sourceStack source stack
+     * @return resolved
+     */
+    @Nullable
+    T resolve(@NotNull CommandSourceStack sourceStack) throws CommandSyntaxException;
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java b/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..942d38eaf0cd77ec896958ba335d6e3456b7e871
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/CustomArgumentType.java
@@ -0,0 +1,104 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * An argument type that wraps around a primitive argument.
+ * This argument is special in that the underlying primitive argument type will
+ * be sent to the client.
+ *
+ * @param <T> type
+ * @param <P> primitive type
+ */
+@ApiStatus.Experimental
+public abstract class CustomArgumentType<T, P> implements ArgumentType<T> {
+
+    @NotNull
+    private final ArgumentType<P> vanillaPrimitiveType;
+
+    protected CustomArgumentType(@NotNull ArgumentType<P> primitive) {
+        VanillaArgumentTypes.PROVIDER.validatePrimitiveType(primitive);
+        this.vanillaPrimitiveType = primitive;
+    }
+
+    /**
+     * Parses the argument using the primitive argument type then converting
+     * it.
+     * @param reader string reader
+     * @return value
+     * @throws CommandSyntaxException if an error occurs while parsing
+     */
+    @NotNull
+    @Override
+    public T parse(@NotNull StringReader reader) throws CommandSyntaxException {
+        return this.convert(this.vanillaPrimitiveType.parse(reader));
+    }
+
+    /**
+     * Converts the value from the primitive type to this argument type.
+     *
+     * @param baseType primitive argument provided value
+     * @return converted value
+     * @throws CommandSyntaxException if an exception occurs while parsing
+     */
+    @NotNull
+    public abstract T convert(@NotNull P baseType) throws CommandSyntaxException;
+
+    /**
+     * Gets the primitive type that this argument uses,
+     * or the type that is sent to the client.
+     *
+     * @return primitive argument
+     */
+    @NotNull
+    public final ArgumentType<P> getPrimitiveType() {
+        return this.vanillaPrimitiveType;
+    }
+
+    /**
+     * Cannot be controlled by the server.
+     * Returned in cases where there are multiple arguments in the same node.
+     * This helps differentiate and tell the player what the possible inputs are.
+     *
+     * @return client set examples
+     */
+    @NotNull
+    @Override
+    public final Collection<String> getExamples() {
+        return this.vanillaPrimitiveType.getExamples();
+    }
+
+    /**
+     * Provides a list of suggestions to show to the client.
+     *
+     * @param context command context
+     * @param builder suggestion builder
+     * @return suggestions
+     * @param <S> context type
+     */
+    @Override
+    public <S> @NotNull CompletableFuture<Suggestions> listSuggestions(@NotNull CommandContext<S> context, @NotNull SuggestionsBuilder builder) {
+        return ArgumentType.super.listSuggestions(context, builder);
+    }
+
+    /**
+     * Returns if the custom argument itself should handle sugggestion
+     * parsing instead of the primitive.
+     *
+     * @return handles suggestions
+     */
+    public boolean handleSuggestions() {
+        return false;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a39d092b9d54a7ab4f4e0f65f0c4b59db1e5db9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentResponse.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import net.kyori.adventure.chat.SignedMessage;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Argument type returned from the Message argument.
+ */
+@ApiStatus.Experimental
+public interface MessageArgumentResponse {
+
+    /**
+     * Content of the message
+     *
+     * @return player made message
+     */
+    @NotNull
+    String content();
+
+    /**
+     * Resolves a signed message from this response.
+     * This will use context stored in the command source stack
+     * and signed arguments sent from the client.
+     * <p>
+     * In the case that signed message information isn't provided, a "system"
+     * signed message will be provided instead.
+     * @param argumentName argument name
+     * @param context context
+     * @return signed message
+     * @throws CommandSyntaxException syntax exception
+     */
+    @NotNull
+    CompletableFuture<SignedMessage> resolveSignedMessage(@NotNull String argumentName, @NotNull CommandContext<CommandSourceStack> context) throws CommandSyntaxException;
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/SelectorArgumentResolver.java b/src/main/java/io/papermc/paper/command/brigadier/argument/SelectorArgumentResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4247fefa3215788ed4698dd6653bd17ffc36a58
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/SelectorArgumentResolver.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * Represents a selector argument which requires
+ * the context of a command source stack to be fully resolved.
+ * @param <T> type
+ */
+@ApiStatus.Experimental
+public interface SelectorArgumentResolver<T> extends ArgumentResolver<T> {
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProvider.java b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..64e311e6ea7281c1dd854de08349c279694c9d02
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProvider.java
@@ -0,0 +1,61 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.brigadier.arguments.ArgumentType;
+import io.papermc.paper.math.BlockPosition;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.HeightMap;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+
+@ApiStatus.Internal
+interface VanillaArgumentProvider {
+
+    @NotNull
+    ArgumentType<SelectorArgumentResolver<Entity>> entity();
+
+    @NotNull
+    ArgumentType<SelectorArgumentResolver<Player>> player();
+
+    @NotNull
+    ArgumentType<SelectorArgumentResolver<List<Entity>>> entities();
+
+    @NotNull
+    ArgumentType<SelectorArgumentResolver<List<Player>>> players();
+
+    @NotNull
+    ArgumentType<ArgumentResolver<Collection<PlayerProfile>>> playerProfiles();
+
+    @NotNull
+    ArgumentType<ArgumentResolver<BlockPosition>> blockPos();
+
+    @NotNull
+    ArgumentType<BlockState> blockState();
+
+    @NotNull
+    ArgumentType<ItemStack> itemStack();
+
+    @NotNull ArgumentType<NamedTextColor> namedColor();
+
+    @NotNull
+    ArgumentType<Component> component();
+
+    @NotNull
+    ArgumentType<MessageArgumentResponse> signedMessage();
+
+    @NotNull ArgumentType<HeightMap> heightMap();
+
+    @NotNull
+    ArgumentType<UUID> uuid();
+
+    void validatePrimitiveType(@NotNull ArgumentType<?> type);
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentTypes.java b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentTypes.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3c3a1f144905a871cd9ffaba186c6837f84668e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentTypes.java
@@ -0,0 +1,172 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.brigadier.arguments.ArgumentType;
+import io.papermc.paper.math.BlockPosition;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.HeightMap;
+import org.bukkit.block.BlockState;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.ServiceLoader;
+import java.util.UUID;
+
+/**
+ * Vanilla argument registry
+ * <p>
+ * These provide rich argument parsing on the client and
+ * may also provide additional signing context.
+ */
+@ApiStatus.Experimental
+public final class VanillaArgumentTypes {
+
+    @NotNull
+    static final VanillaArgumentProvider PROVIDER = ServiceLoader.load(VanillaArgumentProvider.class)
+        .findFirst()
+        .orElseThrow();
+
+    /**
+     * Represents a selector that can capture any
+     * entity.
+     *
+     * @return argument that takes one entity
+     */
+    @NotNull
+    public static ArgumentType<SelectorArgumentResolver<Entity>> entity() {
+        return PROVIDER.entity();
+    }
+
+    /**
+     * Represents a selector that can capture multiple
+     * entities.
+     *
+     * @return argument that takes multiple entities
+     */
+    @NotNull
+    public static ArgumentType<SelectorArgumentResolver<List<Entity>>> entities() {
+        return PROVIDER.entities();
+    }
+
+    /**
+     * Represents a selector that can capture a
+     * player entity.
+     *
+     * @return argument that takes one player
+     */
+    @NotNull
+    public static ArgumentType<SelectorArgumentResolver<Player>> player() {
+        return PROVIDER.player();
+    }
+
+    /**
+     * Represents a selector that can capture multiple
+     * player entities.
+     *
+     * @return argument that takes multiple players
+     */
+    @NotNull
+    public static ArgumentType<SelectorArgumentResolver<List<Player>>> players() {
+        return PROVIDER.players();
+    }
+
+    /**
+     * Represents a selector that provides list
+     * of player profiles
+     *
+     * @return player profile arguments
+     */
+    @NotNull
+    public static ArgumentType<ArgumentResolver<Collection<PlayerProfile>>> playerProfiles() {
+        return PROVIDER.playerProfiles();
+    }
+
+    /**
+     * A block position argument.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<ArgumentResolver<BlockPosition>> blockPos() {
+        return PROVIDER.blockPos();
+    }
+
+    /**
+     * A blockstate argument which will provide rich parsing for specifying
+     * the specific block variant and then the block entity NBT if applicable.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<BlockState> blockState() {
+        return PROVIDER.blockState();
+    }
+
+    /**
+     * An ItemStack argument which provides rich parsing for
+     * specifying item material and item NBT information.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<ItemStack> itemStack() {
+        return PROVIDER.itemStack();
+    }
+
+    /**
+     * A NamedTextColor argument which provides a color.
+     *
+     * @return argument
+     */
+    public static @NotNull ArgumentType<NamedTextColor> namedColor() {
+        return PROVIDER.namedColor();
+    }
+
+    /**
+     * A component argument.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<Component> component() {
+        return PROVIDER.component();
+    }
+
+    /**
+     * A signed message argument.
+     * This argument can be resolved to retreieve the underlying
+     * signed message.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<MessageArgumentResponse> signedMessage() {
+        return PROVIDER.signedMessage();
+    }
+
+    /**
+     * A argument for getting a heightmap type.
+     *
+     * @return argument
+     */
+    public static @NotNull ArgumentType<HeightMap> heightMap() {
+        return PROVIDER.heightMap();
+    }
+
+    /**
+     * A uuid argument.
+     *
+     * @return argument
+     */
+    @NotNull
+    public static ArgumentType<UUID> uuid() {
+        return PROVIDER.uuid();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/event/server/ServerResourcesLoadEvent.java b/src/main/java/io/papermc/paper/event/server/ServerResourcesLoadEvent.java
index 6a39b263de9bc7f2e05a3303b520604a27f0a94a..b17ac471825d8b931adb19cec90320da108edcb3 100644
--- a/src/main/java/io/papermc/paper/event/server/ServerResourcesLoadEvent.java
+++ b/src/main/java/io/papermc/paper/event/server/ServerResourcesLoadEvent.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.event.server;
 
+import io.papermc.paper.command.brigadier.Commands;
 import org.bukkit.event.HandlerList;
 import org.bukkit.event.server.ServerEvent;
 import org.jetbrains.annotations.ApiStatus;
@@ -16,8 +17,15 @@ public class ServerResourcesLoadEvent extends ServerEvent {
 
     public static final HandlerList HANDLER_LIST = new HandlerList();
 
+    private final Commands commands;
+
     @ApiStatus.Internal
-    public ServerResourcesLoadEvent() {
+    public ServerResourcesLoadEvent(final @NotNull Commands commands) {
+        this.commands = commands;
+    }
+
+    public @NotNull Commands getCommands() {
+        return this.commands;
     }
 
     public static @NotNull HandlerList getHandlerList() {
diff --git a/src/main/java/io/papermc/paper/event/server/ServerResourcesReloadedEvent.java b/src/main/java/io/papermc/paper/event/server/ServerResourcesReloadedEvent.java
index d56405b7c6483efec3d316c9b089ce219dca156f..1c05fcecc1092d20b845aff68fe2a3800b50e03f 100644
--- a/src/main/java/io/papermc/paper/event/server/ServerResourcesReloadedEvent.java
+++ b/src/main/java/io/papermc/paper/event/server/ServerResourcesReloadedEvent.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.event.server;
 
+import io.papermc.paper.command.brigadier.Commands;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 
@@ -14,7 +15,8 @@ public class ServerResourcesReloadedEvent extends ServerResourcesLoadEvent {
     private final Cause cause;
 
     @ApiStatus.Internal
-    public ServerResourcesReloadedEvent(@NotNull Cause cause) {
+    public ServerResourcesReloadedEvent(@NotNull Cause cause, @NotNull Commands dispatcher) {
+        super(dispatcher);
         this.cause = cause;
     }
 
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index c661eab343ae76488de701630424e2d589f44fc0..c922111e231e61b889252aae3adebda0a4d698b4 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -249,5 +249,7 @@ public interface UnsafeValues {
      * @throws IllegalStateException if no biome by the given key is registered.
      */
     void setBiomeKey(RegionAccessor accessor, int x, int y, int z, NamespacedKey biomeKey);
+
+    java.util.Map<String, org.bukkit.command.Command> getCommandMirrorMap();
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/command/Command.java b/src/main/java/org/bukkit/command/Command.java
index b791358f90fe92bc2264d9a26492245763813af3..d816d1677dface8cb3035d5adb9919aa75bd8e44 100644
--- a/src/main/java/org/bukkit/command/Command.java
+++ b/src/main/java/org/bukkit/command/Command.java
@@ -488,4 +488,9 @@ public abstract class Command {
     public String toString() {
         return getClass().getName() + '(' + name + ')';
     }
+
+    // Paper start
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public boolean canBeOverriden() { return false; }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/command/FormattedCommandAlias.java b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
index 9d4f553c04784cca63901a56a7aea62a5cae1d72..abe256e1e45ce28036da4aa1586715bc8a1a3414 100644
--- a/src/main/java/org/bukkit/command/FormattedCommandAlias.java
+++ b/src/main/java/org/bukkit/command/FormattedCommandAlias.java
@@ -117,7 +117,7 @@ public class FormattedCommandAlias extends Command {
             index = formatString.indexOf('$', index);
         }
 
-        return formatString;
+        return formatString.trim(); // Paper - Causes an extra space at the end, breaks with brig commands
     }
 
     @NotNull
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index ac9a28922f8a556944a4c3649d74c32c622f0cb0..29a6227e51588c2df427d3b5c5a88189da361216 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -22,10 +22,18 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public class SimpleCommandMap implements CommandMap {
-    protected final Map<String, Command> knownCommands = new HashMap<String, Command>();
+    protected final Map<String, Command> knownCommands; // Paper
     private final Server server;
 
     public SimpleCommandMap(@NotNull final Server server) {
+    // Paper start
+        this(server, org.bukkit.Bukkit.getUnsafe().getCommandMirrorMap());
+    }
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public SimpleCommandMap(@NotNull final Server server, Map<String, Command> backing) {
+        this.knownCommands = backing;
+    // Paper end
         this.server = server;
         setDefaultCommands();
     }
@@ -102,7 +110,10 @@ public class SimpleCommandMap implements CommandMap {
      */
     private synchronized boolean register(@NotNull String label, @NotNull Command command, boolean isAlias, @NotNull String fallbackPrefix) {
         knownCommands.put(fallbackPrefix + ":" + label, command);
-        if ((command instanceof BukkitCommand || isAlias) && knownCommands.containsKey(label)) {
+        // Paper start
+        Command known = knownCommands.get(label);
+        if ((command instanceof BukkitCommand || isAlias) && (known != null && !known.canBeOverriden())) {
+        // Paper end
             // Request is for an alias/fallback command and it conflicts with
             // a existing command or previous alias ignore it
             // Note: This will mean it gets removed from the commands list of active aliases
@@ -114,7 +125,9 @@ public class SimpleCommandMap implements CommandMap {
         // If the command exists but is an alias we overwrite it, otherwise we return
         Command conflict = knownCommands.get(label);
         if (conflict != null && conflict.getLabel().equals(label)) {
+            if (!conflict.canBeOverriden()) { // Paper
             return false;
+            } // Paper
         }
 
         if (!isAlias) {
