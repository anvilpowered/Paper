From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 1 Aug 2022 22:50:34 -0400
Subject: [PATCH] Brigadier based command API

== AT ==
public net.minecraft.commands.arguments.blocks.BlockInput tag

diff --git a/src/main/java/com/mojang/brigadier/tree/CommandNode.java b/src/main/java/com/mojang/brigadier/tree/CommandNode.java
index 39844531b03eb8a6c70700b4ecbf0ff1a557424d..71c455ed0eaf8bf50eb7bbc9283ba652eca82dce 100644
--- a/src/main/java/com/mojang/brigadier/tree/CommandNode.java
+++ b/src/main/java/com/mojang/brigadier/tree/CommandNode.java
@@ -35,6 +35,8 @@ public abstract class CommandNode<S> implements Comparable<CommandNode<S>> {
     private final boolean forks;
     private Command<S> command;
     public LiteralCommandNode<CommandSourceStack> clientNode = null; // Paper
+    public CommandNode<io.papermc.paper.command.brigadier.CommandSourceStack> unwrappedCached = null; // Paper
+    public CommandNode<io.papermc.paper.command.brigadier.CommandSourceStack> apiCached = null; // Paper
     // CraftBukkit start
     public void removeCommand(String name) {
         this.children.remove(name);
@@ -205,4 +207,11 @@ public abstract class CommandNode<S> implements Comparable<CommandNode<S>> {
     }
 
     public abstract Collection<String> getExamples();
+    // Paper start
+    public void clearAll() {
+        this.children.clear();
+        this.literals.clear();
+        this.arguments.clear();
+    }
+    // Paper end
 }
diff --git a/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorDispatcher.java b/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorDispatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9dd07c9f6dab01aa04e0aa4736c823bda859b22
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorDispatcher.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+
+public class ApiMirrorDispatcher extends CommandDispatcher<CommandSourceStack> {
+
+    public static final CommandDispatcher<CommandSourceStack> INSTANCE = new ApiMirrorDispatcher();
+
+    public ApiMirrorDispatcher() {
+        super(new ApiMirrorRootNode());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorRootNode.java b/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorRootNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..e680b6e5be851f7d6fa3ff04059e2d59568e67ef
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/ApiMirrorRootNode.java
@@ -0,0 +1,151 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.BoolArgumentType;
+import com.mojang.brigadier.arguments.DoubleArgumentType;
+import com.mojang.brigadier.arguments.FloatArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.arguments.LongArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.ArgumentCommandNode;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import com.mojang.brigadier.tree.RootCommandNode;
+import io.papermc.paper.command.brigadier.argument.WrappedArgumentCommandNode;
+import io.papermc.paper.command.brigadier.argument.WrapperArgumentType;
+import net.minecraft.commands.synchronization.ArgumentTypeInfos;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.Collection;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+@SuppressWarnings({"unchecked", "rawtypes"})
+/*
+ * This node does special conversion on children, THIS IS SENT TO THE CLIENT!
+ */
+public class ApiMirrorRootNode extends RootCommandNode<CommandSourceStack> {
+
+    private static final Set<Class<?>> BRIG_PRIMITIVES = Set.of(
+        BoolArgumentType.class,
+        DoubleArgumentType.class,
+        FloatArgumentType.class,
+        IntegerArgumentType.class,
+        LongArgumentType.class,
+        StringArgumentType.class
+    );
+
+    private static final CommandDispatcher<net.minecraft.commands.CommandSourceStack> DISPATCHER = MinecraftServer.getServer().vanillaCommandDispatcher.getDispatcher();
+
+    /*
+    Strategy:
+    In this case, we want to be able to properly map over custom arguments to the client.
+    LiteralCommandNode -> Nothing special
+    ArgumentCommandNode -> If WrapperArgumentType, instead make an ArgumentCommandNode with the (vanilla) wrapped ArgumentType
+    ALL:
+    Remap children,
+    redirect
+     */
+    private CommandNode<CommandSourceStack> unwrapWrappedArguments(CommandNode<CommandSourceStack> apiWrapped) {
+        if (apiWrapped.unwrappedCached != null) {
+            return apiWrapped.unwrappedCached;
+        }
+
+        CommandNode<CommandSourceStack> rebuiltNode;
+        if (apiWrapped instanceof LiteralCommandNode<CommandSourceStack> original) {
+            rebuiltNode = this.recreateLiteral(original);
+        } else if (apiWrapped instanceof ArgumentCommandNode original) {
+            ArgumentType<?> unwrappedArgType = original.getType();
+            // Is this argument wrapped?
+            if (unwrappedArgType instanceof WrapperArgumentType<?, ?> wrappedNmsBrigArg) {
+                if (!ArgumentTypeInfos.isClassRecognized(wrappedNmsBrigArg.getWrapped().getClass())) {
+                    throw new IllegalArgumentException("Custom argument type was passed, this was not a recognized type to send to the client! You must only pass vanilla arguments or primitive brig args in the wrapper!");
+                }
+                // Wrap the node in a wrapped argument node
+                rebuiltNode = this.createWrappedArgument(original, wrappedNmsBrigArg);
+            } else if (ArgumentTypeInfos.isClassRecognized(unwrappedArgType.getClass())) {
+                if (BRIG_PRIMITIVES.contains(unwrappedArgType.getClass())) {
+                    // Is this argument whitelisted?
+                    rebuiltNode = original;
+                } else {
+                    // Is this argument an NMS argument?
+                    throw new IllegalArgumentException("NMS argument type was passed (%s), should be wrapped inside an WrapperArgumentType. Don't add NMS args here!".formatted(unwrappedArgType));
+                }
+            } else {
+                throw new IllegalArgumentException("Custom unknown argument type was passed, should be wrapped inside an WrapperArgumentType.");
+            }
+        } else {
+            throw new IllegalArgumentException("Unknown command node passed.");
+        }
+
+        for (CommandNode<CommandSourceStack> child : apiWrapped.getChildren()) {
+            rebuiltNode.addChild(this.unwrapWrappedArguments(child));
+        }
+        apiWrapped.unwrappedCached = rebuiltNode;
+        rebuiltNode.apiCached = apiWrapped;
+
+        return rebuiltNode;
+    }
+
+    private CommandNode<CommandSourceStack> rewrapPossibleWrappedNode(CommandNode<net.minecraft.commands.CommandSourceStack> node) {
+        if (node == null) {
+            return null;
+        }
+
+        if (node.apiCached != null) {
+            return node.apiCached;
+        }
+
+        // We don't know the type of this, or where this came from.
+        // Return a shadow, where we will allow the api to handle this but have
+        // restrictive access.
+
+        CommandNode<CommandSourceStack> shadow = new ShadowBrigNode(node);
+        node.apiCached = shadow;
+        return shadow;
+    }
+
+    @Override
+    public void addChild(CommandNode<CommandSourceStack> node) {
+        CommandNode convertedNode = this.unwrapWrappedArguments(node);
+        DISPATCHER.getRoot().addChild(convertedNode);
+    }
+
+    @Override
+    public Collection<CommandNode<CommandSourceStack>> getChildren() {
+        return DISPATCHER.getRoot().getChildren().stream().map(this::rewrapPossibleWrappedNode).collect(Collectors.toList());
+    }
+
+    @Override
+    public CommandNode<CommandSourceStack> getChild(String name) {
+        return this.rewrapPossibleWrappedNode(DISPATCHER.getRoot().getChild(name));
+    }
+
+    @Override
+    public void removeCommand(String name) {
+        DISPATCHER.getRoot().removeCommand(name);
+    }
+
+    private CommandNode<CommandSourceStack> createWrappedArgument(ArgumentCommandNode node, WrapperArgumentType wrapperArgumentType) {
+        CommandNode redirectNode = node.getRedirect() == null ? null : this.unwrapWrappedArguments(node.getRedirect());
+        SuggestionProvider suggestionProvider;
+        // If there is already a custom suggestion provider, ignore.
+        if (node.getCustomSuggestions() != null) {
+            suggestionProvider = node.getCustomSuggestions();
+        } else {
+            // If however we want to handle suggestions ourselves, reference the wrapper.
+            suggestionProvider = wrapperArgumentType.handleSuggestions() ? wrapperArgumentType::listSuggestions : null;
+        }
+
+        return new WrappedArgumentCommandNode<>(node.getName(), wrapperArgumentType, wrapperArgumentType.getWrapped(), node.getCommand(), node.getRequirement(), redirectNode, node.getRedirectModifier(), node.isFork(), suggestionProvider);
+    }
+
+    private CommandNode<CommandSourceStack> recreateLiteral(LiteralCommandNode<CommandSourceStack> node) {
+        CommandNode redirectNode = node.getRedirect() == null ? null : this.unwrapWrappedArguments(node.getRedirect());
+
+        return new LiteralCommandNode<>(node.getLiteral(), node.getCommand(), node.getRequirement(), redirectNode, node.getRedirectModifier(), node.isFork());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b33c6cf2366568641e6f2fd7f74fb74f6ea0145
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.Message;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.chat.ComponentUtils;
+import org.jetbrains.annotations.NotNull;
+
+public final class MessageComponentSerializerImpl implements MessageComponentSerializer {
+
+    @Override
+    public @NotNull Component deserialize(@NotNull Message input) {
+        return PaperAdventure.asAdventure(ComponentUtils.fromMessage(input));
+    }
+
+    @Override
+    public @NotNull Message serialize(@NotNull Component component) {
+        return PaperAdventure.asVanilla(component);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PaperBrigadier.java b/src/main/java/io/papermc/paper/command/brigadier/PaperBrigadier.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a1d5677e45aa3f8f7f91a3983c607ed83261094
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/PaperBrigadier.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
+
+import java.util.List;
+
+public class PaperBrigadier {
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public static Command wrapNode(CommandNode node) {
+        Commands commands = MinecraftServer.getServer().vanillaCommandDispatcher;
+
+        if (node instanceof LiteralCommandNode) {
+            if (node instanceof PluginCommandNode pluginCommandNode) {
+                return new PluginVanillaCommandWrapper(pluginCommandNode.getName(), pluginCommandNode.getDescription(), pluginCommandNode.getUsageText(), List.of(), commands, node, pluginCommandNode.getPlugin());
+            } else {
+                return new VanillaCommandWrapper(commands, node);
+            }
+        } else {
+            throw new IllegalArgumentException("Unsure how to wrap a " + node);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..da614755bd9e871b90b7739bb469420c8838e082
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.command.brigadier;
+
+import com.destroystokyo.paper.brigadier.BukkitBrigadierCommandSource;
+import net.kyori.adventure.chat.SignedMessage;
+import net.minecraft.network.chat.PlayerChatMessage;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.command.CommandSender;
+
+public interface PaperCommandSourceStack extends CommandSourceStack, BukkitBrigadierCommandSource {
+
+    net.minecraft.commands.CommandSourceStack getHandle();
+
+    @Override
+    default CommandSigningContext getCommandSigningContext() {
+        return argumentName -> {
+            PlayerChatMessage chatMessage = PaperCommandSourceStack.this.getHandle().getSigningContext().getArgument(argumentName);
+            if (chatMessage == null) {
+                return null;
+            }
+
+            return chatMessage.adventureView();
+        };
+    }
+
+    @Override
+    default org.bukkit.entity.Entity getBukkitEntity() {
+        return this.getHandle().getEntity() != null ? this.getHandle().getEntity().getBukkitEntity() : null;
+    }
+
+    @Override
+    default org.bukkit.World getBukkitWorld() {
+        return this.getHandle().getLevel() != null ? this.getHandle().getLevel().getWorld() : null;
+    }
+
+    @Override
+    default org.bukkit.Location getBukkitLocation() {
+        Vec3 pos = this.getHandle().getPosition();
+        org.bukkit.World world = this.getBukkitWorld();
+        Vec2 rot = this.getHandle().getRotation();
+        return world != null && pos != null ? new org.bukkit.Location(world, pos.x, pos.y, pos.z, rot != null ? rot.x : 0, rot != null ? rot.y : 0) : null;
+    }
+
+    @Override
+    default CommandSender getBukkitSender() {
+        return this.getHandle().getBukkitSender();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PluginVanillaCommandWrapper.java b/src/main/java/io/papermc/paper/command/brigadier/PluginVanillaCommandWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..bdb7223453be2ed971941ab57e226133e42b76ec
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/PluginVanillaCommandWrapper.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.tree.CommandNode;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import org.bukkit.command.PluginIdentifiableCommand;
+import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+// Exists to that /help can show the plugin
+public class PluginVanillaCommandWrapper extends VanillaCommandWrapper implements PluginIdentifiableCommand {
+
+    private final Plugin plugin;
+
+    public PluginVanillaCommandWrapper(String name, String description, String usageMessage, List<String> aliases, Commands dispatcher, CommandNode<CommandSourceStack> vanillaCommand, Plugin plugin) {
+        super(name, description, usageMessage, aliases, dispatcher, vanillaCommand);
+        this.plugin = plugin;
+    }
+
+    @Override
+    public @NotNull Plugin getPlugin() {
+        return this.plugin;
+    }
+
+    // Show in help menu!
+    @Override
+    public boolean isRegistered() {
+        return true;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/ShadowBrigNode.java b/src/main/java/io/papermc/paper/command/brigadier/ShadowBrigNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..46035a28f180cc7cc7b97ad1f15d023c595863cf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/ShadowBrigNode.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+
+import java.util.Collection;
+
+public class ShadowBrigNode extends LiteralCommandNode<CommandSourceStack> {
+
+    public ShadowBrigNode(CommandNode<net.minecraft.commands.CommandSourceStack> node) {
+        super(node.getName(), context -> 0, (s) -> false, node.getRedirect() == null ? null : new ShadowBrigNode(node.getRedirect()), null, node.isFork());
+    }
+
+    @Override
+    public Collection<CommandNode<CommandSourceStack>> getChildren() {
+        throw new UnsupportedOperationException("Cannot retrieve children from this node.");
+    }
+
+    @Override
+    public CommandNode<CommandSourceStack> getChild(String name) {
+        throw new UnsupportedOperationException("Cannot retrieve children from this node.");
+    }
+
+    @Override
+    public void addChild(CommandNode<CommandSourceStack> node) {
+        throw new UnsupportedOperationException("Cannot modify children for this node.");
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f986b4b745a65f7cff6933d4941450b22b71056
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.command.brigadier.argument;
+
+public record MessageArgumentImpl(String message) implements MessageArgumentResponse {
+    @Override
+    public String content() {
+        return this.message;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..72b77d403cd1ea61cfd47cd12d96faa0105b94e2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.arguments.MessageArgument;
+import net.minecraft.commands.arguments.UuidArgument;
+import net.minecraft.commands.arguments.blocks.BlockStateArgument;
+import net.minecraft.commands.arguments.item.ItemArgument;
+import net.minecraft.data.registries.VanillaRegistries;
+import net.minecraft.world.flag.FeatureFlagSet;
+import net.minecraft.world.flag.FeatureFlags;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.UUID;
+
+public class VanillaArgumentProviderImpl implements VanillaArguments.VanillaArgumentProvider {
+
+    private final CommandBuildContext commandbuildcontext = CommandBuildContext.simple(VanillaRegistries.createLookup(), FeatureFlagSet.of(FeatureFlags.VANILLA)); // TODO
+
+    @Override
+    public ArgumentType<ItemStack> itemStack() {
+        return this.of(ItemArgument.item(this.commandbuildcontext), (result) -> {
+            return CraftItemStack.asBukkitCopy(result.createItemStack(1, true));
+        });
+    }
+
+    @Override
+    public ArgumentType<BlockState> blockState() {
+        return this.of(BlockStateArgument.block(this.commandbuildcontext), (result) -> {
+            return CraftBlockStates.getBlockState(result.getState(), result.tag);
+        });
+    }
+
+    @Override
+    public ArgumentType<MessageArgumentResponse> signedMessage() {
+        return this.of(MessageArgument.message(), (result) -> {
+            return new MessageArgumentImpl(result.getText());
+        });
+    }
+
+    @Override
+    public ArgumentType<UUID> uuid() {
+        return this.of(UuidArgument.uuid(), (identity) -> identity);
+    }
+
+    private <B, C> ArgumentType<C> of(ArgumentType<B> base, ResultConverter<B, C> converter) {
+        return new WrapperArgumentType<>(base) {
+            @Override
+            public @NotNull C convert(B baseType) throws CommandSyntaxException {
+                return converter.convert(baseType);
+            }
+        };
+    }
+
+    @FunctionalInterface
+    interface ResultConverter<T, R> {
+
+        R convert(T type) throws CommandSyntaxException;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java b/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a838bab16b33025b9a2eae8325f353ad9689e1b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.Command;
+import com.mojang.brigadier.RedirectModifier;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContextBuilder;
+import com.mojang.brigadier.context.ParsedArgument;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.ArgumentCommandNode;
+import com.mojang.brigadier.tree.CommandNode;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import net.minecraft.commands.synchronization.ArgumentTypeInfos;
+
+import java.util.function.Predicate;
+
+/*
+Basically this converts the argument to a different type when parsing.
+ */
+public class WrappedArgumentCommandNode<NMS, API> extends ArgumentCommandNode<CommandSourceStack, NMS> {
+
+    private final ArgumentType<API> argument;
+
+    public WrappedArgumentCommandNode(String name, ArgumentType<API> argument, ArgumentType<NMS> nms, Command<CommandSourceStack> command, Predicate<CommandSourceStack> requirement, CommandNode<CommandSourceStack> redirect, RedirectModifier<CommandSourceStack> modifier, boolean forks, SuggestionProvider<CommandSourceStack> customSuggestions) {
+        super(name, nms, command, requirement, redirect, modifier, forks, customSuggestions);
+        if (!ArgumentTypeInfos.isClassRecognized(nms.getClass())) {
+            // Is this argument an NMS argument?
+            throw new IllegalArgumentException("Unexpected argument type was passed. This should be an NMS type!");
+        }
+
+        this.argument = argument;
+    }
+
+    // See ArgumentCommandNode#parse
+    @Override
+    public void parse(StringReader reader, CommandContextBuilder<CommandSourceStack> contextBuilder) throws CommandSyntaxException {
+        final int start = reader.getCursor();
+        API result = this.argument.parse(reader); // Use the api argument parser
+        final ParsedArgument<CommandSourceStack, API> parsed = new ParsedArgument<>(start, reader.getCursor(), result); // Return an API parsed argument instead.
+
+        contextBuilder.withArgument(this.getName(), parsed);
+        contextBuilder.withNode(this, parsed.getRange());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitBrigForwardingMap.java b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitBrigForwardingMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd1dfc6f478932c69c63503b229b65e7ee3c18c7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitBrigForwardingMap.java
@@ -0,0 +1,197 @@
+package io.papermc.paper.command.brigadier.bukkit;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import io.papermc.paper.command.brigadier.PaperBrigadier;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/*
+This map is supposed to act as a legacy bridge for the command map and the command dispatcher.
+ */
+public class BukkitBrigForwardingMap extends HashMap<String, Command> {
+
+    private final CommandDispatcher<CommandSourceStack> dispatcher = Bukkit.getServer().getCommandDispatcher();
+
+    @Override
+    public int size() {
+        return this.dispatcher.getRoot().getChildren().size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.size() != 0;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        if (key == null) {
+            return false;
+        }
+
+        // Do any children match?
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            if (child instanceof LiteralCommandNode<CommandSourceStack> literalCommandNode && literalCommandNode.getLiteral().equals(key)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        if (value == null) {
+            return false;
+        }
+
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            // If child is a bukkit command node, we can convert it!
+            if (child instanceof BukkitCommandNode bukkitCommandNode) {
+                return bukkitCommandNode.getBukkitCommand().equals(value);
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public Command get(Object key) {
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            if (child instanceof LiteralCommandNode<CommandSourceStack> literalCommandNode && literalCommandNode.getLiteral().equals(key)) {
+                if (literalCommandNode instanceof BukkitCommandNode bukkitCommandNode) {
+                    return bukkitCommandNode.getBukkitCommand();
+                }
+
+                return PaperBrigadier.wrapNode(child);
+            }
+        }
+
+
+        return null;
+    }
+
+    @Nullable
+    @Override
+    public Command put(String key, Command value) {
+        this.dispatcher.getRoot().removeCommand(key); // Override previous command
+        this.dispatcher.getRoot().addChild(BukkitCommandNode.of(key, value));
+        return null;
+    }
+
+    @Override
+    public Command remove(Object key) {
+        Command old = this.get(key);
+        if (old != null) {
+            this.dispatcher.getRoot().removeCommand((String) key);
+        }
+        return old;
+    }
+
+    @Override
+    public void putAll(@NotNull Map<? extends String, ? extends Command> m) {
+        for (Entry<? extends String, ? extends Command> entry : m.entrySet()) {
+            this.put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    @Override
+    public void clear() {
+        this.dispatcher.getRoot().clearAll();
+    }
+
+    // TODO: Mutability?
+
+    @NotNull
+    @Override
+    public Set<String> keySet() {
+        Set<String> keys = new HashSet<>();
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            if (child instanceof LiteralCommandNode<CommandSourceStack> literalCommandNode) {
+                keys.add(literalCommandNode.getLiteral());
+            }
+        }
+
+        return keys;
+    }
+
+    @NotNull
+    @Override
+    public Collection<Command> values() {
+        List<Command> commands = new ArrayList<>();
+
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            if (child instanceof LiteralCommandNode<CommandSourceStack> literalCommandNode) {
+                if (literalCommandNode instanceof BukkitCommandNode bukkitCommandNode) {
+                    commands.add(bukkitCommandNode.getBukkitCommand());
+                } else {
+                    commands.add(PaperBrigadier.wrapNode(child));
+                }
+            }
+        }
+
+        return commands;
+    }
+
+
+    @NotNull
+    @Override
+    public Set<Entry<String, Command>> entrySet() {
+        Set<Entry<String, Command>> commands = new HashSet<>();
+
+        for (CommandNode<CommandSourceStack> child : this.dispatcher.getRoot().getChildren()) {
+            if (child instanceof LiteralCommandNode<CommandSourceStack> literalCommandNode) {
+                if (literalCommandNode instanceof BukkitCommandNode bukkitCommandNode) {
+                    commands.add(new Entry<>() {
+                        @Override
+                        public String getKey() {
+                            return bukkitCommandNode.getName();
+                        }
+
+                        @Override
+                        public Command getValue() {
+                            return bukkitCommandNode.getBukkitCommand();
+                        }
+
+                        @Override
+                        public Command setValue(Command value) {
+                            return bukkitCommandNode.getBukkitCommand();
+                        }
+                    });
+                } else {
+                    Command wrapped = PaperBrigadier.wrapNode(child);
+                    commands.add(new Entry<>() {
+                        @Override
+                        public String getKey() {
+                            return child.getName();
+                        }
+
+                        @Override
+                        public Command getValue() {
+                            return wrapped;
+                        }
+
+                        @Override
+                        public Command setValue(Command value) {
+                            return wrapped;
+                        }
+                    });
+                }
+            }
+        }
+
+        return commands;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e5af5b6d56f9cebe11852e1e207ad0ae08dc666
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java
@@ -0,0 +1,126 @@
+package io.papermc.paper.command.brigadier.bukkit;
+
+import co.aikar.timings.Timing;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.logging.Level;
+
+public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
+
+    private final Command command;
+
+    private BukkitCommandNode(String literal, Command command, BukkitBrigCommand bukkitBrigCommand) {
+        super(
+            literal, bukkitBrigCommand, s -> command.testPermissionSilent(s.getBukkitSender()),
+            null, null, false
+        );
+        this.command = command;
+    }
+
+    public static BukkitCommandNode of(String name, Command command) {
+        BukkitBrigCommand bukkitBrigCommand = new BukkitBrigCommand(command, name);
+        BukkitCommandNode commandNode = new BukkitCommandNode(name, command, bukkitBrigCommand);
+        commandNode.addChild(
+            RequiredArgumentBuilder.<CommandSourceStack, String>argument("args", StringArgumentType.greedyString()).suggests(BukkitBrigSuggestionProvider.INSTANCE).executes(bukkitBrigCommand).build()
+        );
+
+        return commandNode;
+    }
+
+    public Command getBukkitCommand() {
+        return this.command;
+    }
+
+    static class BukkitBrigCommand implements com.mojang.brigadier.Command<CommandSourceStack> {
+
+        private final org.bukkit.command.Command command;
+        private final String literal;
+
+        BukkitBrigCommand(org.bukkit.command.Command command, String literal) {
+            this.command = command;
+            this.literal = literal;
+        }
+
+        @Override
+        public int run(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {
+            CommandSender sender = context.getSource().getBukkitSender();
+
+            // Plugins do weird things to workaround normal registration
+            if (this.command.timings == null) {
+                this.command.timings = co.aikar.timings.TimingsManager.getCommandTiming(null, this.command);
+            }
+
+            String[] args = org.apache.commons.lang3.StringUtils.split(context.getInput(), ' '); // fix adjacent spaces (from console/plugins) causing empty array elements
+
+            try (Timing ignored = this.command.timings.startTiming()) {
+                // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
+                this.command.execute(sender, this.literal, Arrays.copyOfRange(args, 1, args.length));
+            }
+
+            // return true as command was handled
+            return 1;
+        }
+    }
+
+    static class BukkitBrigSuggestionProvider implements SuggestionProvider<CommandSourceStack> {
+
+        public static final SuggestionProvider<CommandSourceStack> INSTANCE = new BukkitBrigSuggestionProvider();
+
+        @Override
+        public CompletableFuture<Suggestions> getSuggestions(CommandContext<CommandSourceStack> context, SuggestionsBuilder builder) throws CommandSyntaxException {
+            // Paper start
+            org.bukkit.command.CommandSender sender = context.getSource().getBukkitSender();
+            if (!(sender instanceof org.bukkit.entity.Player player)) {
+                return CompletableFuture.completedFuture(builder.build());
+            }
+
+            String message = builder.getInput();
+            List<String> results = List.of(); // Use a list as incase of fail. Causes HUGE spam
+            Location pos = context.getSource().getBukkitLocation();
+            try {
+                if (message.startsWith("/")) {
+                    // Trim leading '/' if present (won't always be present in command blocks)
+                    message = message.substring(1);
+                }
+                if (pos == null) {
+                    results = Bukkit.getCommandMap().tabComplete(player, message);
+                } else {
+                    results = Bukkit.getCommandMap().tabComplete(player, message, pos.clone());
+                }
+            } catch (CommandException ex) {
+                player.sendMessage(ChatColor.RED + "An internal error occurred while attempting to tab-complete this command");
+                Bukkit.getServer().getLogger().log(Level.SEVERE, "Exception when " + player.getName() + " attempted to tab complete " + message, ex);
+            }
+
+            // Paper end
+
+            // Defaults to sub nodes, but we have just one giant args node, so offset accordingly
+            builder = builder.createOffset(builder.getInput().lastIndexOf(' ') + 1);
+
+            for (String s : results) {
+                builder.suggest(s);
+            }
+
+            return builder.buildFuture();
+        }
+    }
+
+}
diff --git a/src/main/java/net/minecraft/commands/CommandSourceStack.java b/src/main/java/net/minecraft/commands/CommandSourceStack.java
index ae5dd08de75a7ed231295f306fd0974da3988249..4de42ae21d288a348583aaa763fda6af9e432463 100644
--- a/src/main/java/net/minecraft/commands/CommandSourceStack.java
+++ b/src/main/java/net/minecraft/commands/CommandSourceStack.java
@@ -41,7 +41,7 @@ import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import com.mojang.brigadier.tree.CommandNode; // CraftBukkit
 
-public class CommandSourceStack implements SharedSuggestionProvider, com.destroystokyo.paper.brigadier.BukkitBrigadierCommandSource { // Paper
+public class CommandSourceStack implements SharedSuggestionProvider, io.papermc.paper.command.brigadier.PaperCommandSourceStack { // Paper
 
     public static final SimpleCommandExceptionType ERROR_NOT_PLAYER = new SimpleCommandExceptionType(Component.translatable("permissions.requires.player"));
     public static final SimpleCommandExceptionType ERROR_NOT_ENTITY = new SimpleCommandExceptionType(Component.translatable("permissions.requires.entity"));
@@ -171,25 +171,7 @@ public class CommandSourceStack implements SharedSuggestionProvider, com.destroy
         return this.textName;
     }
 
-    // Paper start
-    @Override
-    public org.bukkit.entity.Entity getBukkitEntity() {
-        return getEntity() != null ? getEntity().getBukkitEntity() : null;
-    }
 
-    @Override
-    public org.bukkit.World getBukkitWorld() {
-        return getLevel() != null ? getLevel().getWorld() : null;
-    }
-
-    @Override
-    public org.bukkit.Location getBukkitLocation() {
-        Vec3 pos = getPosition();
-        org.bukkit.World world = getBukkitWorld();
-        Vec2 rot = getRotation();
-        return world != null && pos != null ? new org.bukkit.Location(world, pos.x, pos.y, pos.z, rot != null ? rot.y : 0, rot != null ? rot.x : 0) : null;
-    }
-    // Paper end
 
     @Override
     public boolean hasPermission(int level) {
@@ -411,6 +393,12 @@ public class CommandSourceStack implements SharedSuggestionProvider, com.destroy
         return this.level.enabledFeatures();
     }
 
+    // Paper start
+    @Override
+    public CommandSourceStack getHandle() {
+        return this;
+    }
+    // Paper end
     // CraftBukkit start
     public org.bukkit.command.CommandSender getBukkitSender() {
         return this.source.getBukkitSender(this);
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 330f6c79417378da855326b4da665f9d240e748d..e66d74d476352f9333224ed3e5b25448c8fd0852 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -227,6 +227,16 @@ public class Commands {
             }
         }
         // Paper end
+        // Paper start
+        // Create legacy minecraft namespace commands
+        for (final CommandNode<CommandSourceStack> node : new java.util.ArrayList<>(this.dispatcher.getRoot().getChildren())) {
+            this.dispatcher.register(
+                com.mojang.brigadier.builder.LiteralArgumentBuilder.<CommandSourceStack>literal("minecraft:" + node.getName())
+                    .executes(node.getCommand())
+                    .redirect(node)
+            );
+        }
+        // Paper end
         // CraftBukkit start
     }
 
@@ -298,6 +308,11 @@ public class Commands {
     }
 
     public int performCommand(ParseResults<CommandSourceStack> parseresults, String s, String label) { // CraftBukkit
+    // Paper start
+        return this.performCommand(parseresults, s, label, false);
+    }
+    public int performCommand(ParseResults<CommandSourceStack> parseresults, String s, String label, boolean throwCommandError) {
+    // Paper end
         CommandSourceStack commandlistenerwrapper = (CommandSourceStack) parseresults.getContext().getSource();
 
         commandlistenerwrapper.getServer().getProfiler().push(() -> {
@@ -343,6 +358,7 @@ public class Commands {
                 b1 = 0;
                 return b1;
             } catch (Exception exception) {
+                if (throwCommandError) throw exception;
                 MutableComponent ichatmutablecomponent2 = Component.literal(exception.getMessage() == null ? exception.getClass().getName() : exception.getMessage());
 
                 if (Commands.LOGGER.isDebugEnabled()) {
@@ -439,6 +455,7 @@ public class Commands {
     }
 
     private void fillUsableCommands(CommandNode<CommandSourceStack> tree, CommandNode<SharedSuggestionProvider> result, CommandSourceStack source, Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> resultNodes) {
+        resultNodes.keySet().removeIf((node) -> !org.spigotmc.SpigotConfig.sendNamespaced && node.getName().contains( ":" )); // Paper - Remove namedspaced from result nodes to prevent redirect trimming ~ see comment below
         Iterator iterator = tree.getChildren().iterator();
 
         boolean registeredAskServerSuggestionsForTree = false; // Paper - tell clients to ask server for suggestions for EntityArguments
@@ -453,6 +470,42 @@ public class Commands {
 
             if (commandnode2.canUse(source)) {
                 ArgumentBuilder argumentbuilder = commandnode2.createBuilder(); // CraftBukkit - decompile error
+                // Paper start
+                /*
+                Because of how commands can be yeeted right left and center due to bad bukkit practices
+                we need to be able to ensure that ALL commands are registered (even redirects).
+
+                What this will do is IF the redirect seems to be "dead" it will create a builder and essentially populate (flatten)
+                all the children from the dead redirect to the node.
+
+                So, if minecraft:msg redirects to msg but the original msg node has been overriden minecraft:msg will now act as msg and will explicilty inherit its children.
+
+                The only way to fix this is to either:
+                - Send EVERYTHING flattened, don't use redirects
+                - Don't allow command nodes to be deleted
+                - Do this :)
+                 */
+
+                // Is there a valid command redirect?
+                if (argumentbuilder.getRedirect() != null && (CommandNode) resultNodes.get(argumentbuilder.getRedirect()) == null) {
+                    // Create the argument builder with the same values as the specified node, but with a different literal and populated children
+
+                    CommandNode<CommandSourceStack> redirect = argumentbuilder.getRedirect();
+                    // Diff copied from LiteralCommand#createBuilder
+                    final com.mojang.brigadier.builder.LiteralArgumentBuilder<CommandSourceStack> builder = com.mojang.brigadier.builder.LiteralArgumentBuilder.literal(commandnode2.getName());
+                    builder.requires(redirect.getRequirement());
+                    builder.forward(redirect.getRedirect(), redirect.getRedirectModifier(), redirect.isFork());
+                    if (redirect.getCommand() != null) {
+                        builder.executes(redirect.getCommand());
+                    }
+                    // Diff copied from LiteralCommand#createBuilder
+                    for (CommandNode<CommandSourceStack> child : redirect.getChildren()) {
+                        builder.then(child);
+                    }
+
+                    argumentbuilder = builder;
+                }
+                // Paper end
 
                 argumentbuilder.requires((icompletionprovider) -> {
                     return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index bfc4ee36befb925ab4eb6b96f5c1aa6c76bf711f..7f7949a66a2037d53f8e17dfc3c5c723df0879d2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -267,10 +267,10 @@ public final class CraftServer implements Server {
     private final Logger logger = Logger.getLogger("Minecraft");
     private final ServicesManager servicesManager = new SimpleServicesManager();
     private final CraftScheduler scheduler = new CraftScheduler();
-    private final CraftCommandMap commandMap = new CraftCommandMap(this);
+    private final CraftCommandMap commandMap; // Paper - Move down
     private final SimpleHelpMap helpMap = new SimpleHelpMap(this);
     private final StandardMessenger messenger = new StandardMessenger();
-    private final SimplePluginManager pluginManager = new SimplePluginManager(this, this.commandMap);
+    private final SimplePluginManager pluginManager; // Paper - Move down
     private final StructureManager structureManager;
     protected final DedicatedServer console;
     protected final DedicatedPlayerList playerList;
@@ -320,6 +320,10 @@ public final class CraftServer implements Server {
         this.structureManager = new CraftStructureManager(console.getStructureManager());
 
         Bukkit.setServer(this);
+        // Paper start
+        this.commandMap = new CraftCommandMap(this);
+        this.pluginManager = new SimplePluginManager(this, this.commandMap);
+         // Paper end
 
         // Register all the Enchantments and PotionTypes now so we can stop new registration immediately after
         Enchantments.SHARPNESS.getClass();
@@ -516,45 +520,11 @@ public final class CraftServer implements Server {
         Commands dispatcher = console.vanillaCommandDispatcher;
 
         // Build a list of all Vanilla commands and create wrappers
-        for (CommandNode<CommandSourceStack> cmd : dispatcher.getDispatcher().getRoot().getChildren()) {
-            // Spigot start
-            VanillaCommandWrapper wrapper = new VanillaCommandWrapper(dispatcher, cmd);
-            if (org.spigotmc.SpigotConfig.replaceCommands.contains( wrapper.getName() ) ) {
-                if (first) {
-                    this.commandMap.register("minecraft", wrapper);
-                }
-            } else if (!first) {
-                this.commandMap.register("minecraft", wrapper);
-            }
-            // Spigot end
-        }
+        // Paper - Replace implementation
     }
 
     public void syncCommands() {
-        // Clear existing commands
-        Commands dispatcher = console.resources.managers().commands = new Commands();
-
-        // Register all commands, vanilla ones will be using the old dispatcher references
-        for (Map.Entry<String, Command> entry : this.commandMap.getKnownCommands().entrySet()) {
-            String label = entry.getKey();
-            Command command = entry.getValue();
-
-            if (command instanceof VanillaCommandWrapper) {
-                LiteralCommandNode<CommandSourceStack> node = (LiteralCommandNode<CommandSourceStack>) ((VanillaCommandWrapper) command).vanillaCommand;
-                if (!node.getLiteral().equals(label)) {
-                    LiteralCommandNode<CommandSourceStack> clone = new LiteralCommandNode(label, node.getCommand(), node.getRequirement(), node.getRedirect(), node.getRedirectModifier(), node.isFork());
-
-                    for (CommandNode<CommandSourceStack> child : node.getChildren()) {
-                        clone.addChild(child);
-                    }
-                    node = clone;
-                }
-
-                dispatcher.getDispatcher().getRoot().addChild(node);
-            } else {
-                new BukkitCommandWrapper(this, entry.getValue()).register(dispatcher.getDispatcher(), label);
-            }
-        }
+        Commands dispatcher = this.getHandle().getServer().vanillaCommandDispatcher; // Paper - We now register directly to the dispatcher.
 
         // Refresh commands
         for (ServerPlayer player : this.getHandle().players) {
@@ -925,22 +895,31 @@ public final class CraftServer implements Server {
                 throw new RuntimeException("Exception processing dispatch command", e.getCause());
             }
         }
-        // Paper End
-        if (this.commandMap.dispatch(sender, commandLine)) {
-            return true;
-        }
+        return this.dispatchCommand(org.bukkit.craftbukkit.command.VanillaCommandWrapper.getListener(sender), commandLine);
+    }
 
-        // Spigot start
-        if (!org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty()) {
-            // Paper start
-            org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(sender, commandLine, org.spigotmc.SpigotConfig.unknownCommandMessage);
-            Bukkit.getServer().getPluginManager().callEvent(event);
-            if (event.message() != null) {
-                sender.sendMessage(event.message());
-            }
-            // Paper end
+    public boolean dispatchCommand(CommandSourceStack sourceStack, String commandLine) {
+        net.minecraft.commands.Commands commands = this.getHandle().getServer().vanillaCommandDispatcher;
+        com.mojang.brigadier.CommandDispatcher<CommandSourceStack> dispatcher = commands.getDispatcher();
+        com.mojang.brigadier.ParseResults<CommandSourceStack> results = dispatcher.parse(commandLine, sourceStack);
+
+        Command target = null; // TODO
+        CommandSender sender = sourceStack.getBukkitSender();
+        String[] args = org.apache.commons.lang3.StringUtils.split(commandLine, ' '); // Paper - fix adjacent spaces (from console/plugins) causing empty array elements
+
+        try {
+            commands.performCommand(results, commandLine, commandLine, true);
+        } catch (CommandException ex) {
+            this.pluginManager.callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerCommandException(ex, target, sender, args))); // Paper
+            //target.timings.stopTiming(); // Spigot // Paper
+            throw ex;
+        } catch (Throwable ex) {
+            //target.timings.stopTiming(); // Spigot // Paper
+            String msg = "Unhandled exception executing '" + commandLine + "' in " + target;
+            this.pluginManager.callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerCommandException(ex, target, sender, args))); // Paper
+            throw new CommandException(msg, ex);
         }
-        // Spigot end
+        // Paper end
 
         return false;
     }
@@ -2937,5 +2916,10 @@ public final class CraftServer implements Server {
         return this.potionBrewer;
     }
 
+    @Override
+    public com.mojang.brigadier.CommandDispatcher<io.papermc.paper.command.brigadier.CommandSourceStack> getCommandDispatcher() {
+        return io.papermc.paper.command.brigadier.ApiMirrorDispatcher.INSTANCE;
+    }
+
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java b/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
index 26f3a2799e687731d883e7733591f6934479e88d..f449310eaafec6e0ce5f61cfe8e6f76c3ee57ec9 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
@@ -20,6 +20,7 @@ import org.bukkit.command.CommandException;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftServer;
 
+@Deprecated(forRemoval = true) // Paper - Don't use
 public class BukkitCommandWrapper implements com.mojang.brigadier.Command<CommandSourceStack>, Predicate<CommandSourceStack>, SuggestionProvider<CommandSourceStack>, com.destroystokyo.paper.brigadier.BukkitBrigadierCommand<CommandSourceStack> { // Paper
 
     private final CraftServer server;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java b/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
index 6035af2cf08353b3d3801220d8116d8611a0cd37..8e99fe260b461094b2fa90ee2757f6c11c68b058 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
@@ -25,11 +25,18 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import org.bukkit.entity.minecart.CommandMinecart;
 
-public final class VanillaCommandWrapper extends BukkitCommand {
+public class VanillaCommandWrapper extends BukkitCommand { // Paper
 
     private final Commands dispatcher;
     public final CommandNode<CommandSourceStack> vanillaCommand;
 
+    // Paper start
+    public VanillaCommandWrapper(String name, String description, String usageMessage, List<String> aliases, Commands dispatcher, CommandNode<CommandSourceStack> vanillaCommand) {
+        super(name, description, usageMessage, aliases);
+        this.dispatcher = dispatcher;
+        this.vanillaCommand = vanillaCommand;
+    }
+    // Paper end
     public VanillaCommandWrapper(Commands dispatcher, CommandNode<CommandSourceStack> vanillaCommand) {
         super(vanillaCommand.getName(), "A Mojang provided command.", vanillaCommand.getUsageText(), Collections.EMPTY_LIST);
         this.dispatcher = dispatcher;
@@ -116,4 +123,10 @@ public final class VanillaCommandWrapper extends BukkitCommand {
     private String toDispatcher(String[] args, String name) {
         return name + ((args.length > 0) ? " " + Joiner.on(' ').join(args) : "");
     }
+    // Paper start
+    @Override
+    public boolean canBeOverriden() {
+        return true;
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java b/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
index 40b66adcb5aac64212b1937dc506ebb60f2eed83..44287bc95009dc1b6c70443759895ee28ecc54d9 100644
--- a/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/help/SimpleHelpMap.java
@@ -199,15 +199,18 @@ public class SimpleHelpMap implements HelpMap {
     }
 
     private String getCommandPluginName(Command command) {
+        // Paper start - Move up
+        if (command instanceof PluginIdentifiableCommand) {
+            return ((PluginIdentifiableCommand) command).getPlugin().getName();
+        }
+        // Paper end
         if (command instanceof VanillaCommandWrapper) {
             return "Minecraft";
         }
         if (command instanceof BukkitCommand) {
             return "Bukkit";
         }
-        if (command instanceof PluginIdentifiableCommand) {
-            return ((PluginIdentifiableCommand) command).getPlugin().getName();
-        }
+        // Paper - Move PluginIdentifiableCommand instanceof check to allow brig commands
         return null;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 17336102d37a5ab05c3b3c93fcf46961d0ffa7e2..4e421c607057da3fa00250d508ae163f1b4bb2b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -620,6 +620,11 @@ public final class CraftMagicNumbers implements UnsafeValues {
         net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> biomeBase = cra.getHandle().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME).getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.BIOME, org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(biomeKey)));
         cra.setBiome(x, y, z, biomeBase);
     }
+
+    @Override
+    public java.util.Map<String, org.bukkit.command.Command> getCommandMirrorMap() {
+        return new io.papermc.paper.command.brigadier.bukkit.BukkitBrigForwardingMap();
+    }
     // Paper end
 
     /**
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer
new file mode 100644
index 0000000000000000000000000000000000000000..2428b577b9bf0eac6947f5d919cbb51f7aca3d50
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer
@@ -0,0 +1 @@
+io.papermc.paper.command.brigadier.MessageComponentSerializerImpl
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArguments$VanillaArgumentProvider b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArguments$VanillaArgumentProvider
new file mode 100644
index 0000000000000000000000000000000000000000..b2fdb8351c2abb55283850a929d2a87aa6ecb80f
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArguments$VanillaArgumentProvider
@@ -0,0 +1 @@
+io.papermc.paper.command.brigadier.argument.VanillaArgumentProviderImpl
diff --git a/src/test/java/org/bukkit/support/DummyServer.java b/src/test/java/org/bukkit/support/DummyServer.java
index 2ddceb709291d3bd713621ffa4020c02ec26bb21..190d44c3a71eea64e921847b8f9effe3f2878134 100644
--- a/src/test/java/org/bukkit/support/DummyServer.java
+++ b/src/test/java/org/bukkit/support/DummyServer.java
@@ -25,86 +25,86 @@ public final class DummyServer implements InvocationHandler {
     static {
         try {
             methods.put(
-                    Server.class.getMethod("getItemFactory"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftItemFactory.instance();
-                        }
+                Server.class.getMethod("getItemFactory"),
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return CraftItemFactory.instance();
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("getName"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return DummyServer.class.getName();
-                        }
+                Server.class.getMethod("getName"),
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return DummyServer.class.getName();
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("getVersion"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return DummyServer.class.getPackage().getImplementationVersion();
-                        }
+                Server.class.getMethod("getVersion"),
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return DummyServer.class.getPackage().getImplementationVersion();
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("getBukkitVersion"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return Versioning.getBukkitVersion();
-                        }
+                Server.class.getMethod("getBukkitVersion"),
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return Versioning.getBukkitVersion();
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("getLogger"),
-                    new MethodHandler() {
-                        final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return logger;
-                        }
+                Server.class.getMethod("getLogger"),
+                new MethodHandler() {
+                    final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return logger;
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("getUnsafe"),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftMagicNumbers.INSTANCE;
-                        }
+                Server.class.getMethod("getUnsafe"),
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return CraftMagicNumbers.INSTANCE;
                     }
-                );
+                }
+            );
             methods.put(
-                    Server.class.getMethod("createBlockData", Material.class),
-                    new MethodHandler() {
-                        final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftBlockData.newData((Material) args[0], null);
-                        }
+                Server.class.getMethod("createBlockData", Material.class),
+                new MethodHandler() {
+                    final Logger logger = Logger.getLogger(DummyServer.class.getCanonicalName());
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return CraftBlockData.newData((Material) args[0], null);
                     }
-                );
+                }
+            );
             methods.put(Server.class.getMethod("getLootTable", NamespacedKey.class),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            NamespacedKey key = (NamespacedKey) args[0];
-                            return new CraftLootTable(key, AbstractTestingBase.DATA_PACK.getLootTables().get(CraftNamespacedKey.toMinecraft(key)));
-                        }
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        NamespacedKey key = (NamespacedKey) args[0];
+                        return new CraftLootTable(key, AbstractTestingBase.DATA_PACK.getLootTables().get(CraftNamespacedKey.toMinecraft(key)));
                     }
-                );
+                }
+            );
             methods.put(Server.class.getMethod("getRegistry", Class.class),
-                    new MethodHandler() {
-                        @Override
-                        public Object handle(DummyServer server, Object[] args) {
-                            return CraftRegistry.createRegistry((Class) args[0], AbstractTestingBase.REGISTRY_CUSTOM);
-                        }
+                new MethodHandler() {
+                    @Override
+                    public Object handle(DummyServer server, Object[] args) {
+                        return CraftRegistry.createRegistry((Class) args[0], AbstractTestingBase.REGISTRY_CUSTOM);
                     }
+                }
             );
             // Paper start - modeled off of TestServer in the API tests module
             methods.put(
@@ -119,7 +119,7 @@ public final class DummyServer implements InvocationHandler {
             DummyServer server = new DummyServer();
             Server instance = Proxy.getProxyClass(Server.class.getClassLoader(), Server.class).asSubclass(Server.class).getConstructor(InvocationHandler.class).newInstance(server);
             Bukkit.setServer(instance);
-            server.pluginManager = new org.bukkit.plugin.SimplePluginManager(instance, new org.bukkit.command.SimpleCommandMap(instance));
+            server.pluginManager = new org.bukkit.plugin.SimplePluginManager(instance, null);
             // Paper end
         } catch (Throwable t) {
             throw new Error(t);
