From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 1 Aug 2022 22:50:34 -0400
Subject: [PATCH] Brigadier based command API


diff --git a/src/main/java/io/papermc/paper/command/brigadier/ApiForwardingRootNode.java b/src/main/java/io/papermc/paper/command/brigadier/ApiForwardingRootNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..e389ca55d98d5da5c062dbdd6bc5757790304aaf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/ApiForwardingRootNode.java
@@ -0,0 +1,101 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.ArgumentCommandNode;
+import com.mojang.brigadier.tree.CommandNode;
+import com.mojang.brigadier.tree.LiteralCommandNode;
+import com.mojang.brigadier.tree.RootCommandNode;
+import io.papermc.paper.command.brigadier.argument.WrappedArgumentCommandNode;
+import io.papermc.paper.command.brigadier.argument.WrapperArgumentType;
+import net.minecraft.commands.synchronization.ArgumentTypeInfos;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+@SuppressWarnings({"unchecked", "rawtypes"})
+public class ApiForwardingRootNode extends RootCommandNode<CommandSourceStack> {
+
+    private final CommandDispatcher<net.minecraft.commands.CommandSourceStack> nmsSourceStack = MinecraftServer.getServer().vanillaCommandDispatcher.getDispatcher();
+    private final List<CommandNode<CommandSourceStack>> apiChildren = new ArrayList<>();
+
+    private final Map<CommandNode<CommandSourceStack>, CommandNode<CommandSourceStack>> cachedUnwrappedArguments = new WeakHashMap<>();
+
+    /*
+    Strategy:
+    Move all BrigadierWrapperArgument types into a ConvertingArgumentCommandNode
+     */
+    private CommandNode<CommandSourceStack> unwrapWrappedArguments(CommandNode<CommandSourceStack> nms) {
+        if (this.cachedUnwrappedArguments.containsKey(nms)) {
+            return this.cachedUnwrappedArguments.get(nms);
+        }
+
+        CommandNode<CommandSourceStack> rebuiltNode;
+        if (nms instanceof LiteralCommandNode<CommandSourceStack> original) {
+            rebuiltNode = this.recreateLiteral(original);
+        } else if (nms instanceof ArgumentCommandNode original) {
+            ArgumentType<?> unwrappedArgType = original.getType();
+            // Is this argument wrapped?
+            if (unwrappedArgType instanceof WrapperArgumentType<?, ?> wrappedNmsBrigArg) {
+                if (!ArgumentTypeInfos.isClassRecognized(wrappedNmsBrigArg.getWrapped().getClass())) {
+                    throw new IllegalArgumentException("Custom argument type was passed, this was not a recognized type to send to the client! You must only pass vanilla arguments or primitive brig args in the wrapper!");
+                }
+                // Wrap the node in a wrapped argument node
+                rebuiltNode = this.createWrappedArgument(original, wrappedNmsBrigArg);
+            } else if (ArgumentTypeInfos.isClassRecognized(unwrappedArgType.getClass())) {
+                // Is this argument an NMS argument?
+                throw new IllegalArgumentException("NMS argument type was passed, should be wrapped inside an WrapperArgumentType. Don't add NMS args here!");
+            } else {
+                throw new IllegalArgumentException("Custom argument type was passed, should be wrapped inside an WrapperArgumentType.");
+            }
+
+        } else {
+            throw new IllegalArgumentException("Unknown command node passed.");
+        }
+
+        for (CommandNode<CommandSourceStack> child : nms.getChildren()) {
+            rebuiltNode.addChild(this.unwrapWrappedArguments(child));
+        }
+        this.cachedUnwrappedArguments.put(nms, rebuiltNode);
+
+        return rebuiltNode;
+    }
+
+    private CommandNode<CommandSourceStack> createWrappedArgument(ArgumentCommandNode node, WrapperArgumentType wrapperArgumentType) {
+        CommandNode redirectNode = node.getRedirect() == null ? null : this.unwrapWrappedArguments(node.getRedirect());
+        SuggestionProvider suggestionProvider;
+        // If there is already a custom suggestion provider, ignore.
+        if (node.getCustomSuggestions() != null) {
+            suggestionProvider = node.getCustomSuggestions();
+        } else {
+            // If however we want to handle suggestions ourselves, reference the wrapper.
+            suggestionProvider = wrapperArgumentType.handleSuggestions() ? wrapperArgumentType::listSuggestions : null;
+        }
+
+        return new WrappedArgumentCommandNode<>(node.getName(), wrapperArgumentType, wrapperArgumentType.getWrapped(), node.getCommand(), node.getRequirement(), redirectNode, node.getRedirectModifier(), node.isFork(), suggestionProvider);
+    }
+
+    private CommandNode<CommandSourceStack> recreateLiteral(LiteralCommandNode<CommandSourceStack> node) {
+        CommandNode redirectNode = node.getRedirect() == null ? null : this.unwrapWrappedArguments(node.getRedirect());
+
+        return new LiteralCommandNode<>(node.getLiteral(), node.getCommand(), node.getRequirement(), redirectNode, node.getRedirectModifier(), node.isFork());
+    }
+
+    @Override
+    public void addChild(CommandNode<CommandSourceStack> node) {
+        this.apiChildren.add(node);
+        CommandNode convertedNode = this.unwrapWrappedArguments(node);
+        this.nmsSourceStack.getRoot().addChild(convertedNode);
+    }
+
+    @Override
+    public Collection<CommandNode<CommandSourceStack>> getChildren() {
+        return this.apiChildren;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..48e55b763b0c92ada24e624b2fe0eb50d187229d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MessageComponentSerializerImpl.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.Message;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.chat.ComponentUtils;
+import org.jetbrains.annotations.NotNull;
+
+public class MessageComponentSerializerImpl implements MessageComponentSerializer {
+
+    @Override
+    public @NotNull Component deserialize(@NotNull Message input) {
+        return PaperAdventure.asAdventure(ComponentUtils.fromMessage(input));
+    }
+
+    @Override
+    public @NotNull Message serialize(@NotNull Component component) {
+        return PaperAdventure.asVanilla(component);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/MirroredCommandDispatcher.java b/src/main/java/io/papermc/paper/command/brigadier/MirroredCommandDispatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..b40783d0c3dcd52d53a7bc8a56eca94e708b7601
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/MirroredCommandDispatcher.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.command.brigadier;
+
+import com.mojang.brigadier.CommandDispatcher;
+
+public class MirroredCommandDispatcher extends CommandDispatcher<CommandSourceStack> {
+
+    public static final CommandDispatcher<CommandSourceStack> INSTANCE = new MirroredCommandDispatcher();
+
+    public MirroredCommandDispatcher() {
+        super(new ApiForwardingRootNode());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a4eaf1ac9fea3abf5b422afc4fe06a3b33e2472
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/PaperCommandSourceStack.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.command.brigadier;
+
+import com.destroystokyo.paper.brigadier.BukkitBrigadierCommandSource;
+import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.command.CommandSender;
+
+public interface PaperCommandSourceStack extends CommandSourceStack, BukkitBrigadierCommandSource {
+
+    net.minecraft.commands.CommandSourceStack getHandle();
+
+    @Override
+    default org.bukkit.entity.Entity getBukkitEntity() {
+        return this.getHandle().getEntity() != null ? this.getHandle().getEntity().getBukkitEntity() : null;
+    }
+
+    @Override
+    default org.bukkit.World getBukkitWorld() {
+        return this.getHandle().getLevel() != null ? this.getHandle().getLevel().getWorld() : null;
+    }
+
+    @Override
+    default org.bukkit.Location getBukkitLocation() {
+        Vec3 pos = this.getHandle().getPosition();
+        org.bukkit.World world = this.getBukkitWorld();
+        Vec2 rot = this.getHandle().getRotation();
+        return world != null && pos != null ? new org.bukkit.Location(world, pos.x, pos.y, pos.z, rot != null ? rot.x : 0, rot != null ? rot.y : 0) : null;
+    }
+
+    @Override
+    default CommandSender getBukkitSender() {
+        return this.getHandle().getBukkitSender();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec15989eab4d5a768feeef2e553ef5756c5bdf75
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/MessageArgumentImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.command.brigadier.argument;
+
+public record MessageArgumentImpl(String message) implements Message {
+    @Override
+    public String getSignedContent() {
+        return this.message;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..af74bda442a8a75a9514b2c662fd6295762a6f1a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/VanillaArgumentProviderImpl.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.arguments.MessageArgument;
+import net.minecraft.commands.arguments.UuidArgument;
+import net.minecraft.commands.arguments.blocks.BlockStateArgument;
+import net.minecraft.commands.arguments.item.ItemArgument;
+import net.minecraft.core.RegistryAccess;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.ItemStack;
+
+import java.util.UUID;
+
+public class VanillaArgumentProviderImpl implements VanillaArgumentProvider {
+
+    private final CommandBuildContext commandbuildcontext = new CommandBuildContext(RegistryAccess.BUILTIN.get());
+
+    @Override
+    public ArgumentType<ItemStack> itemStack() {
+        return this.of(ItemArgument.item(this.commandbuildcontext), (result) -> {
+            return CraftItemStack.asBukkitCopy(result.createItemStack(1, true));
+        });
+    }
+
+    @Override
+    public ArgumentType<BlockState> blockState() {
+        return this.of(BlockStateArgument.block(this.commandbuildcontext), (result) -> {
+            return CraftBlockStates.getBlockState(result.getState(), result.tag);
+        });
+    }
+
+    @Override
+    public ArgumentType<Message> signedMessage() {
+        return this.of(MessageArgument.message(), (result) -> {
+            return new MessageArgumentImpl(result.getText());
+        });
+    }
+
+    @Override
+    public ArgumentType<UUID> uuid() {
+        return this.of(UuidArgument.uuid(), (identity) -> identity);
+    }
+
+    private <B, C> ArgumentType<C> of(ArgumentType<B> base, ResultConverter<B, C> converter) {
+        return new WrapperArgumentType<>(base) {
+            @Override
+            public C convert(B baseType) throws CommandSyntaxException {
+                return converter.convert(baseType);
+            }
+        };
+    }
+
+    @FunctionalInterface
+    interface ResultConverter<T, R> {
+
+        R convert(T type) throws CommandSyntaxException;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java b/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a838bab16b33025b9a2eae8325f353ad9689e1b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/brigadier/argument/WrappedArgumentCommandNode.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.command.brigadier.argument;
+
+import com.mojang.brigadier.Command;
+import com.mojang.brigadier.RedirectModifier;
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContextBuilder;
+import com.mojang.brigadier.context.ParsedArgument;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.SuggestionProvider;
+import com.mojang.brigadier.tree.ArgumentCommandNode;
+import com.mojang.brigadier.tree.CommandNode;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import net.minecraft.commands.synchronization.ArgumentTypeInfos;
+
+import java.util.function.Predicate;
+
+/*
+Basically this converts the argument to a different type when parsing.
+ */
+public class WrappedArgumentCommandNode<NMS, API> extends ArgumentCommandNode<CommandSourceStack, NMS> {
+
+    private final ArgumentType<API> argument;
+
+    public WrappedArgumentCommandNode(String name, ArgumentType<API> argument, ArgumentType<NMS> nms, Command<CommandSourceStack> command, Predicate<CommandSourceStack> requirement, CommandNode<CommandSourceStack> redirect, RedirectModifier<CommandSourceStack> modifier, boolean forks, SuggestionProvider<CommandSourceStack> customSuggestions) {
+        super(name, nms, command, requirement, redirect, modifier, forks, customSuggestions);
+        if (!ArgumentTypeInfos.isClassRecognized(nms.getClass())) {
+            // Is this argument an NMS argument?
+            throw new IllegalArgumentException("Unexpected argument type was passed. This should be an NMS type!");
+        }
+
+        this.argument = argument;
+    }
+
+    // See ArgumentCommandNode#parse
+    @Override
+    public void parse(StringReader reader, CommandContextBuilder<CommandSourceStack> contextBuilder) throws CommandSyntaxException {
+        final int start = reader.getCursor();
+        API result = this.argument.parse(reader); // Use the api argument parser
+        final ParsedArgument<CommandSourceStack, API> parsed = new ParsedArgument<>(start, reader.getCursor(), result); // Return an API parsed argument instead.
+
+        contextBuilder.withArgument(this.getName(), parsed);
+        contextBuilder.withNode(this, parsed.getRange());
+    }
+}
diff --git a/src/main/java/net/minecraft/commands/CommandSourceStack.java b/src/main/java/net/minecraft/commands/CommandSourceStack.java
index e0dd0fc1638377f4d4226d4b2976b901d635dff0..79884a7f8cd54a0a8a1464891a5cc2dbef790626 100644
--- a/src/main/java/net/minecraft/commands/CommandSourceStack.java
+++ b/src/main/java/net/minecraft/commands/CommandSourceStack.java
@@ -39,7 +39,7 @@ import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import com.mojang.brigadier.tree.CommandNode; // CraftBukkit
 
-public class CommandSourceStack implements SharedSuggestionProvider, com.destroystokyo.paper.brigadier.BukkitBrigadierCommandSource { // Paper
+public class CommandSourceStack implements SharedSuggestionProvider, io.papermc.paper.command.brigadier.PaperCommandSourceStack {
 
     public static final SimpleCommandExceptionType ERROR_NOT_PLAYER = new SimpleCommandExceptionType(Component.translatable("permissions.requires.player"));
     public static final SimpleCommandExceptionType ERROR_NOT_ENTITY = new SimpleCommandExceptionType(Component.translatable("permissions.requires.entity"));
@@ -172,26 +172,6 @@ public class CommandSourceStack implements SharedSuggestionProvider, com.destroy
         return this.entity != null ? this.entity.asChatSender() : ChatSender.SYSTEM;
     }
 
-    // Paper start
-    @Override
-    public org.bukkit.entity.Entity getBukkitEntity() {
-        return getEntity() != null ? getEntity().getBukkitEntity() : null;
-    }
-
-    @Override
-    public org.bukkit.World getBukkitWorld() {
-        return getLevel() != null ? getLevel().getWorld() : null;
-    }
-
-    @Override
-    public org.bukkit.Location getBukkitLocation() {
-        Vec3 pos = getPosition();
-        org.bukkit.World world = getBukkitWorld();
-        Vec2 rot = getRotation();
-        return world != null && pos != null ? new org.bukkit.Location(world, pos.x, pos.y, pos.z, rot != null ? rot.x : 0, rot != null ? rot.y : 0) : null;
-    }
-    // Paper end
-
     @Override
     public boolean hasPermission(int level) {
         // CraftBukkit start
@@ -407,6 +387,12 @@ public class CommandSourceStack implements SharedSuggestionProvider, com.destroy
         return this.server.registryAccess();
     }
 
+    // Paper start
+    @Override
+    public CommandSourceStack getHandle() {
+        return this;
+    }
+    // Paper end
     // CraftBukkit start
     public org.bukkit.command.CommandSender getBukkitSender() {
         return this.source.getBukkitSender(this);
diff --git a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
index 9c34abab53cf4229f84b45ac8606e930c70c0e18..5eadc7ac773cdb743c52ebcd8af6a3ce3025d288 100644
--- a/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
+++ b/src/main/java/net/minecraft/commands/arguments/blocks/BlockInput.java
@@ -17,7 +17,7 @@ public class BlockInput implements Predicate<BlockInWorld> {
     private final BlockState state;
     private final Set<Property<?>> properties;
     @Nullable
-    private final CompoundTag tag;
+    public final CompoundTag tag; // Paper
 
     public BlockInput(BlockState state, Set<Property<?>> properties, @Nullable CompoundTag data) {
         this.state = state;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index bfde5bbcccfaa754ec6bdf4f3817981a93e465bd..dc0eaf253b2827a5011b3f957f0804bd6485231c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -516,30 +516,7 @@ public final class CraftServer implements Server {
     }
 
     public void syncCommands() {
-        // Clear existing commands
-        Commands dispatcher = console.resources.managers().commands = new Commands();
-
-        // Register all commands, vanilla ones will be using the old dispatcher references
-        for (Map.Entry<String, Command> entry : this.commandMap.getKnownCommands().entrySet()) {
-            String label = entry.getKey();
-            Command command = entry.getValue();
-
-            if (command instanceof VanillaCommandWrapper) {
-                LiteralCommandNode<CommandSourceStack> node = (LiteralCommandNode<CommandSourceStack>) ((VanillaCommandWrapper) command).vanillaCommand;
-                if (!node.getLiteral().equals(label)) {
-                    LiteralCommandNode<CommandSourceStack> clone = new LiteralCommandNode(label, node.getCommand(), node.getRequirement(), node.getRedirect(), node.getRedirectModifier(), node.isFork());
-
-                    for (CommandNode<CommandSourceStack> child : node.getChildren()) {
-                        clone.addChild(child);
-                    }
-                    node = clone;
-                }
-
-                dispatcher.getDispatcher().getRoot().addChild(node);
-            } else {
-                new BukkitCommandWrapper(this, entry.getValue()).register(dispatcher.getDispatcher(), label);
-            }
-        }
+        Commands dispatcher = this.getHandle().getServer().vanillaCommandDispatcher; // Paper - We now register directly to the dispatcher.
 
         // Refresh commands
         for (ServerPlayer player : this.getHandle().players) {
@@ -2898,5 +2875,10 @@ public final class CraftServer implements Server {
         return this.potionBrewer;
     }
 
+    @Override
+    public com.mojang.brigadier.CommandDispatcher<io.papermc.paper.command.brigadier.CommandSourceStack> getCommandDispatcher() {
+        return io.papermc.paper.command.brigadier.MirroredCommandDispatcher.INSTANCE;
+    }
+
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java b/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
index 2476727cd60034c4df2db36b9ed808e72d7b686f..42f1c17a33f61fa060ba059d1a858809d47c17be 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/BukkitCommandWrapper.java
@@ -20,10 +20,10 @@ import org.bukkit.command.CommandException;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftServer;
 
-public class BukkitCommandWrapper implements com.mojang.brigadier.Command<CommandSourceStack>, Predicate<CommandSourceStack>, SuggestionProvider<CommandSourceStack>, com.destroystokyo.paper.brigadier.BukkitBrigadierCommand<CommandSourceStack> { // Paper
+public class BukkitCommandWrapper implements com.mojang.brigadier.Command<CommandSourceStack>, Predicate<CommandSourceStack>, SuggestionProvider<CommandSourceStack> {
 
     private final CraftServer server;
-    private final Command command;
+    public final Command command; // Paper
 
     public BukkitCommandWrapper(CraftServer server, Command command) {
         this.server = server;
@@ -31,19 +31,10 @@ public class BukkitCommandWrapper implements com.mojang.brigadier.Command<Comman
     }
 
     public LiteralCommandNode<CommandSourceStack> register(CommandDispatcher<CommandSourceStack> dispatcher, String label) {
-        // Paper start - Expose Brigadier to Paper-MojangAPI
-        com.mojang.brigadier.tree.RootCommandNode<CommandSourceStack> root = dispatcher.getRoot();
-        LiteralCommandNode<CommandSourceStack> literal = LiteralArgumentBuilder.<CommandSourceStack>literal(label).requires(this).executes(this).build();
-        com.mojang.brigadier.tree.ArgumentCommandNode<CommandSourceStack, String> defaultArgs = RequiredArgumentBuilder.<CommandSourceStack, String>argument("args", StringArgumentType.greedyString()).suggests(this).executes(this).build();
-        literal.addChild(defaultArgs);
-        com.destroystokyo.paper.event.brigadier.CommandRegisteredEvent<CommandSourceStack> event = new com.destroystokyo.paper.event.brigadier.CommandRegisteredEvent<>(label, this, this.command, root, literal, defaultArgs);
-        if (!event.callEvent()) {
-            return null;
-        }
-        literal = event.getLiteral();
-        root.addChild(literal);
-        return literal;
-        // Paper end
+        return dispatcher.register(
+            LiteralArgumentBuilder.<CommandSourceStack>literal(label).requires(this).executes(this)
+                .then(RequiredArgumentBuilder.<CommandSourceStack, String>argument("args", StringArgumentType.greedyString()).suggests(this).executes(this))
+        );
     }
 
     @Override
@@ -66,7 +57,13 @@ public class BukkitCommandWrapper implements com.mojang.brigadier.Command<Comman
 
     @Override
     public CompletableFuture<Suggestions> getSuggestions(CommandContext<CommandSourceStack> context, SuggestionsBuilder builder) throws CommandSyntaxException {
-        List<String> results = this.server.tabComplete(context.getSource().getBukkitSender(), builder.getInput(), context.getSource().getLevel(), context.getSource().getPosition(), true);
+        // Paper start
+        org.bukkit.command.CommandSender sender = context.getSource().getBukkitSender();
+        if (!(sender instanceof org.bukkit.entity.Player player)) {
+            return CompletableFuture.completedFuture(builder.build());
+        }
+        List<String> results = this.server.tabCompleteCommand(player, builder.getInput(), context.getSource().getLevel(), context.getSource().getPosition());
+        // Paper end
 
         // Defaults to sub nodes, but we have just one giant args node, so offset accordingly
         builder = builder.createOffset(builder.getInput().lastIndexOf(' ') + 1);
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer
new file mode 100644
index 0000000000000000000000000000000000000000..2428b577b9bf0eac6947f5d919cbb51f7aca3d50
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.MessageComponentSerializer
@@ -0,0 +1 @@
+io.papermc.paper.command.brigadier.MessageComponentSerializerImpl
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArgumentProvider b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArgumentProvider
new file mode 100644
index 0000000000000000000000000000000000000000..b2fdb8351c2abb55283850a929d2a87aa6ecb80f
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.command.brigadier.argument.VanillaArgumentProvider
@@ -0,0 +1 @@
+io.papermc.paper.command.brigadier.argument.VanillaArgumentProviderImpl
